'use strict';

function ColorPicker() {
  var self = this;

  self.hours = 'hours';
  self.minutes = 'minutes';
  self.seconds = 'seconds';
  self.red = 'red';
  self.green = 'green';
  self.blue = 'blue';
  self.colors = ko.observable({
    red: {
      class: 'btn-danger',
      interval: self.hours
    },
    green: {
      class: 'btn-success',
      interval: self.minutes
    },
    blue: {
      class: 'btn-primary',
      interval: self.seconds
    }
  });
  self.hoursColor = ko.observable(self.colors().red.class);
  self.minutesColor = ko.observable(self.colors().green.class);
  self.secondsColor = ko.observable(self.colors().blue.class);

  self.update = function (intervalName, color) {
    // Update the selected interval observable property (self.hours, self.minutes, self.seconds) and color
    self[intervalName + 'Color'](self.colors()[color].class);

    // Get the original interval's color key
    var originalColorKey;
    for (var key in self.colors()) {
      if (!self.colors().hasOwnProperty(key)) continue;

      if (self.colors()[key].interval === intervalName) {
        originalColorKey = key;
        break;
      }
    }

    var overriden = self.colors()[color];
    self[overriden.interval + 'Color'](self.colors()[originalColorKey].class);

    var temp = self.colors()[color].interval;
    self.colors()[color].interval = intervalName;
    self.colors()[originalColorKey].interval = temp;
  };
}
'use strict';

var ColorZonesViewModel = function ColorZonesViewModel(options) {
  var self = this;

  var hoverZoneColor = '#660d60';
  var timeFormat = 'HH:mm:ss';
  var _hoverTimeZoneKey, _hoverRegionKey;
  var _selectedZoneInfo;
  var _mouseX, _mouseY;
  var renderer = options.renderer;
  var timeZoneService = options.timeZoneService;
  // UI options
  self.colorPicker = ko.observable(options.colorPicker);
  self.opacity = ko.observable(80);
  self.showTimes = ko.observable(false);
  self.colorAllZones = ko.observable(true);
  // Map options
  self.zoom = ko.observable(1);
  self.centerLat = ko.observable(20);
  self.centerLng = ko.observable(0);
  // Cached zones and regions
  self.timeZones = ko.observableArray();
  self.timeZoneRegions = ko.observable({});

  var _textColor = ko.pureComputed(function () {
    return self.colorAllZones() ? 'white' : 'black';
  });

  // Draw Loop
  renderer.render(function () {
    if (self.timeZones().length === 0) return;

    var timeTexts = [];
    // Trigger the intervals to draw all the zones
    for (var i = 0; i < self.timeZones().length; i++) {
      var timeZone = self.timeZones()[i];

      var current = moment().tz(timeZone.name);
      var hours = adjustTime(current.hours());
      var minutes = adjustTime(current.minutes());
      var seconds = adjustTime(current.seconds());

      var red = getColorInterval(self.colorPicker().red, hours, minutes, seconds);
      var green = getColorInterval(self.colorPicker().green, hours, minutes, seconds);
      var blue = getColorInterval(self.colorPicker().blue, hours, minutes, seconds);

      var color = "#" + red + green + blue;
      if (self.colorAllZones()) {
        renderer.polygon(timeZone.coords, color, self.opacity());
      }

      if (timeZone.centroidPolygon === undefined) continue;
      var zoneInfo = {
        textX: timeZone.centroidPolygon.centroid.x,
        textY: timeZone.centroidPolygon.centroid.y,
        time: current.format(timeFormat),
        colorHex: color
      };
      timeTexts.push(zoneInfo);
      if (_hoverTimeZoneKey && _hoverTimeZoneKey !== '' && _hoverTimeZoneKey === timeZone.name) {
        _selectedZoneInfo = zoneInfo;
      }
    }

    var hoverTimeZone = self.timeZoneRegions()[_hoverTimeZoneKey];
    if (hoverTimeZone) {
      $.each(hoverTimeZone, function (index, value) {
        if (!value || !value.coords || value.coords.length === 0) return;
        // Use the color-zone hex when only coloring the hover region
        var hoverColor = self.colorAllZones() ? hoverZoneColor : _selectedZoneInfo.colorHex;
        renderer.polygon(value.coords, hoverColor, 80);
      });

      if (!self.showTimes()) {
        renderer.text(_mouseX, _mouseY - 5, _selectedZoneInfo.time, _textColor(), true);
      }
      renderer.text(_mouseX, _mouseY - 25, _hoverRegionKey, _textColor(), true);
      renderer.text(_mouseX, _mouseY - 45, _selectedZoneInfo.colorHex, _textColor(), true);
    }

    // Need to do this in a separate loop here to have the times drawn on top
    if (!self.showTimes()) return;
    for (var j = 0; j < timeTexts.length; j++) {
      renderer.text(timeTexts[j].textX, timeTexts[j].textY, timeTexts[j].time, _textColor());
    }
  });

  var _mapCallback;
  // Load the map image
  function loadMap(mapCallback) {
    _mapCallback = mapCallback;
    fetch('/api/color-zones/map?centerLat=' + self.centerLat() + '&centerLng=' + self.centerLng() + '&zoom=' + self.zoom() + '&width=' + options.width + '&height=' + options.height).then(function (response) {
      if (!response.ok) {
        console.error('Something went wrong trying to load the map image...');
        return;
      }
      response.text().then(function (mapUrl) {
        renderer.loadImage(mapUrl);
        if (_mapCallback !== undefined) _mapCallback();
      });
    });
  }
  loadMap();

  // Load the time zones
  timeZoneService.setup(self.centerLat, self.centerLng, self.zoom); // Pass in the observables
  timeZoneService.loadTimeZones(function (errorMessage) {
    console.error(errorMessage);
  }, self.timeZones, self.timeZoneRegions);

  function adjustTime(interval) {
    if (interval < 10) {
      interval = "0" + interval;
    }
    return interval.toString();
  }

  function getColorInterval(color, hours, minutes, seconds) {
    var interval = self.colorPicker().colors()[color].interval;
    switch (interval) {
      case self.colorPicker().hours:
        return hours;
      case self.colorPicker().minutes:
        return minutes;
      case self.colorPicker().seconds:
        return seconds;
      default:
        console.warn('Could not find an interval for: ' + interval + '...');
    }
  }

  function rayCastTest(points, x, y, zoneName) {
    var rayTest = 0;
    var lastPoint = points[points.length - 1];

    for (var j = 0; j < points.length; j++) {
      var point = points[j];

      if (lastPoint.y <= y && point.y >= y || lastPoint.y > y && point.y < y) {
        var slope = (point.x - lastPoint.x) / (point.y - lastPoint.y);
        var testPoint = slope * (y - lastPoint.y) + lastPoint.x;
        if (testPoint < x) {
          rayTest++;
        }
      }
      lastPoint = point;
    }
    // If the count is odd, we are in the polygon
    return rayTest % 2 === 1;
  }

  renderer.addMouseOverEvent(function (x, y) {
    if (self.timeZones().length === 0) return;

    var found = false;
    for (var i = 0; i < self.timeZones().length; i++) {
      var zone = self.timeZones()[i];
      var boundingBox = zone.boundingBox;
      if (boundingBox === undefined) return;

      // Source: https://github.com/dosx/timezone-picker
      if (y > boundingBox.xyMax.y && y < boundingBox.xyMin.y && x > boundingBox.xyMin.x && x < boundingBox.xyMax.x) {
        // Mouse is in the zone bounds, so now have to check if it is in one of this zone's regions
        var regions = self.timeZoneRegions()[zone.name];
        for (var key in regions) {
          if (!regions.hasOwnProperty(key)) continue;
          if (rayCastTest(regions[key].coords, x, y)) {
            _hoverTimeZoneKey = zone.name;
            _hoverRegionKey = key;
            _mouseX = x;
            _mouseY = y;
            return;
          }
        }
      }
    }
  }, self.centerLat(), self.centerLng());

  renderer.addMouseScrollEvent(function (zoom) {
    if (zoom > 1) {
      self.zoom(self.zoom() + 1);
    } else {
      self.zoom(self.zoom() - 1);
    }

    if (self.zoom() < 1) {
      // Can't zoom any lower
      self.zoom(1);
      return;
    }
  });
};
'use strict';

function TimeZoneService(mapWidth) {
  var self = this;

  var mercUnits = mapWidth / 4;

  // This is an observable that the caller passes in
  // It will be updated as the service finishes each of it's requests
  var _timeZonesObservable;
  var _timeZoneRegionsObservable;
  var _centerLat;
  var _centerLng;
  var _zoom;
  var _errorCallback;

  // These need to be observables from ColorZones
  self.setup = function (centerLat, centerLng, zoom) {
    _centerLat = centerLat;
    _centerLng = centerLng;
    _zoom = zoom;
  };

  self.loadTimeZones = function (errorCallback, timeZonesObservable, timeZoneRegionsObservable) {
    _errorCallback = errorCallback;
    if (_centerLat === undefined || _centerLng === undefined || _zoom === undefined) {
      _errorCallback('You need to call TimeZoneService.setCenterCoordinates(centerLat, centerLng, zoom) first!');
      return;
    }
    _timeZonesObservable = timeZonesObservable;
    _timeZoneRegionsObservable = timeZoneRegionsObservable;

    // Load the time zone regions
    fetch('/api/color-zones/hover-regions').then(function (response) {
      if (!response.ok) {
        _errorCallback('Something went wrong trying to load the time zone regions...');
        return;
      }
      response.json().then(function (json) {
        var hoverRegions = JSON.parse(json);

        function getTimeZone(hoverRegion) {
          // Each hover region contains a hover region array of points
          var coords = [];
          for (var i = 0; i < hoverRegion.hoverRegion.length; i++) {
            // Every two points in the hover region are the lat and lng
            var region = hoverRegion.hoverRegion[i];
            for (var j = 0; j < region.points.length; j += 2) {
              var pointPair = region.points.slice(j, j + 2);
              var xy = getXY(pointPair[0], pointPair[1]);
              coords.push(xy);
            }
          }
          return new TimeZone(hoverRegion.name, coords);
        }

        for (var i = 0; i < hoverRegions.length; i++) {
          var timeZone = getTimeZone(hoverRegions[i]);
          loadZonePolygons(timeZone);
          _timeZonesObservable().push(timeZone);
        }

        // All time zones are loaded, so we can now load the bounding boxes
        loadBoundingBoxes();
      });
    });

    self.reloadCoordinates = function () {
      for (var i = 0; i < _timeZonesObservable().length; i++) {
        var coords = _timeZonesObservable()[i].coords;
        for (var j = 0; j < coords.length; j++) {
          coords[j] = getXY(coords[j].x, coords[j].y);
        }
      }
    };

    // Load the bounding boxes
    function loadBoundingBoxes() {
      fetch('/api/color-zones/map-bounds').then(function (response) {
        if (!response.ok) {
          // TODO Handle error here
          return;
        }
        response.json().then(function (json) {
          var boundingBoxes = JSON.parse(json);
          for (var i = 0; i < boundingBoxes.length; i++) {
            var box = boundingBoxes[i];
            for (var j = 0; j < _timeZonesObservable().length; j++) {
              if (_timeZonesObservable()[j].matchesId(box.name)) {
                var xyMin = getXY(box.boundingBox.ymin, box.boundingBox.xmin);
                var xyMax = getXY(box.boundingBox.ymax, box.boundingBox.xmax);
                _timeZonesObservable()[j].boundingBox = {
                  xyMin: xyMin,
                  xyMax: xyMax
                };
                break;
              }
            }
          }
        });
      });
    }

    // Load the polygons for a time zone
    function loadZonePolygons(timeZone) {
      var zoneName = timeZone.name.replace(/\/|_/g, '-');
      fetch('/api/color-zones/polygons/' + zoneName).then(function (response) {
        if (!response.ok) {
          _errorCallback('Something went wrong trying to load the time zone polygons for ' + zoneName + '...');
          return;
        }
        response.json().then(function (json) {
          var data = JSON.parse(json);
          var polygons = {};

          for (var i = 0; i < data.polygons.length; i++) {
            // Loop through all the points in the polygon
            // Every 2 points are a lat & lng pair
            var polygonData = data.polygons[i];
            var coords = [];

            for (var j = 0; j < polygonData.points.length; j += 2) {
              var coord = polygonData.points.slice(j, j + 2);
              var xy = getXY(coord[0], coord[1]);
              coords.push(xy);
            }

            // Check if the polygon has already been created
            var polygon = polygons[polygonData.name];
            if (polygon) {
              polygon.coords = polygon.coords.concat(coords);
            } else {
              polygon = new Polygon(polygonData.name, coords, getXY(polygonData.centroid[1], polygonData.centroid[0]));
              polygons[polygonData.name] = polygon;
            }
          }

          // Check to each polygon to find the largest by seeing if it has the most edges
          // Use the largest polygon's centroid as the timezone centroid
          var centroidName,
              maxPoints = 0;
          $.each(polygons, function (index, value) {
            if (value.coords.length > maxPoints) {
              maxPoints = value.coords.length;
              centroidName = value.name;
            }
          });

          if (!_timeZoneRegionsObservable()[timeZone.name]) {
            _timeZoneRegionsObservable()[timeZone.name] = [];
          }
          _timeZoneRegionsObservable()[timeZone.name] = polygons;
          timeZone.centroidPolygon = polygons[centroidName];
        });
      });
    }
  };

  function getXY(lat, lng) {
    var centerX = mercX(_centerLng());
    var centerY = mercY(_centerLat());
    var x = mercX(lng) - centerX;
    var y = mercY(lat) - centerY;
    return { x: x, y: y };
  }

  function mercX(lng) {
    lng = toRadians(lng);
    var a = mercUnits / Math.PI * Math.pow(2, _zoom());
    var b = lng + Math.PI;
    return a * b;
  }

  function mercY(lat) {
    lat = toRadians(lat);
    var a = mercUnits / Math.PI * Math.pow(2, _zoom());
    var b = Math.tan(Math.PI / 4 + lat / 2);
    var c = Math.PI - Math.log(b);
    return a * c;
  }

  function toRadians(degrees) {
    return degrees * (Math.PI / 180);
  }
}
'use strict';

function TooltipService(tooltips) {
  var self = this;

  var storageKey = 'tooltipsShown';

  self.loadToolips = function () {
    var tooltipsShown = localStorage.getItem(storageKey);
    if (tooltips.length === 0 || tooltipsShown) return;
    showTooltip(0);
  };

  function showTooltip(index) {
    if (index === tooltips.length) return;
    try {
      tooltips[index].id.tooltip('show');
    } catch (e) {}

    setTimeout(function () {
      try {
        tooltips[index].id.tooltip('dispose');
      } catch (e) {}
      // Increment the index to try to get the next tooltip
      index++;
      if (!tooltips[index]) {
        // Don't show the tooltips again
        localStorage.setItem(storageKey, true);
      }
      showTooltip(index);
    }, tooltips[index].timeout * 1000);
  }
}
"use strict";

function LatLng(lat, lng) {
  var self = this;
  self.lat = lat;
  self.lng = lng;
}
'use strict';

function Polygon(name, coords, centroid) {
  var self = this;

  self.name = name;
  self.coords = coords;
  self.centroid = centroid;

  self.id = ko.pureComputed(function () {
    return self.name.replace(/\/|_/g, '-');
  });
}
'use strict';

function TimeZone(name, coords) {
  var self = this;

  self.name = name;
  self.coords = coords;
  self.polygons = undefined;
  self.centroidPolygon = undefined;
  self.boundingBox = undefined;

  self.matchesId = function (idToMatch) {
    return self.id() === idToMatch.replace(/\/|_/g, '-');
  };

  self.id = ko.pureComputed(function () {
    return self.name.replace(/\/|_/g, '-');
  });
}