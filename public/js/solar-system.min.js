'use strict';

function Orbital(parent, options) {
  var self = this;

  self.x = 0;
  self.y = 0;
  self.name = 'Orbital';
  self.parentOrbital = parent;
  self.radius = options.radius;
  self.distance = options.distance;
  self.level = options.level;
  self.color = options.color ? options.color : randomColor();
  self.children = [];

  var speed = random(0.02, 0.04),
      angle = random(0, Math.PI);

  self.createChildren = function (orbitalOptions) {
    var orbitalOption = orbitalOptions[self.level];

    var minSize = parseInt(orbitalOption.minSize()),
        maxSize = parseInt(orbitalOption.maxSize()),
        minDistance = parseInt(orbitalOption.minDistance()),
        maxDistance = parseInt(orbitalOption.maxDistance()),
        count = orbitalOption.count();

    var previousDistance = 0;
    for (var i = 0; i < count; i++) {
      var max = maxSize * (0.3 * i);
      if (maxSize < minSize) maxSize = minSize + 1;

      var radius = randomInt(minSize, maxSize);
      var distance = randomInt(minDistance, maxDistance) + previousDistance;
      previousDistance = distance;

      var childOptions = {
        radius: radius,
        distance: distance,
        level: orbitalOption.level(),
        color: orbitalOption.color()
      };

      var child = new Orbital(self, childOptions);
      self.children.push(child);

      if (self.level < 2) {
        child.createChildren(orbitalOptions);
      }
    }
  };

  self.setPosition = function (x, y) {
    self.x = x;
    self.y = y;
  };
  self.setName = function (name) {
    self.name = name;
  };

  self.update = function () {
    angle += speed;
  };

  self.render = function (renderer, parent) {
    var x, y;
    if (parent) {
      var r = self.radius + self.distance + parent.radius * 0.5;
      self.x = parent.x + r * Math.cos(angle);
      self.y = parent.y + r * Math.sin(angle);
    }

    renderer.ellipse(self.x, self.y, self.radius, self.color);
  };
}
'use strict';

function OrbitalOptions(type, renderer) {
  var self = this;

  self.type = type;

  self.level = ko.observable().extend({ numeric: 0 });
  self.radius = ko.observable().extend({ numeric: 0 });
  self.minSize = ko.observable().extend({ numeric: 0 });
  self.maxSize = ko.observable().extend({ numeric: 0 });
  self.minDistance = ko.observable().extend({ numeric: 0 });
  self.maxDistance = ko.observable().extend({ numeric: 0 });
  self.minCount = ko.observable().extend({ numeric: 0 });
  self.maxCount = ko.observable().extend({ numeric: 0 });
  var _color, _useRandomColor;

  self.count = function () {
    return randomInt(self.minCount(), self.maxCount());
  };

  self.color = function () {
    return _useRandomColor ? randomColor() : _color;
  };

  ko.computed(function () {
    if (self.minSize() > self.maxSize()) {
      self.minSize(self.maxSize());
    }
    if (self.maxSize() < self.minSize()) {
      self.maxSize(self.minSize());
    }
  });

  ko.computed(function () {
    if (self.minDistance() > self.maxDistance()) {
      self.minDistance(self.maxDistance());
    }
  });
  ko.computed(function () {
    var maxDistance = renderer.width / 2 / self.minCount();
    if (self.maxDistance() > maxDistance) {
      self.maxDistance(maxDistance);
    }
  });

  ko.computed(function () {
    if (self.minCount() > self.maxCount()) {
      self.minCount(self.maxCount());
    }
  });
  ko.computed(function () {
    if (self.maxCount() < self.minCount()) {
      self.maxCount(self.minCount());
    }
  });

  self.save = function (useDefault) {
    var options;
    if (useDefault) {
      // Reset everything to the defaults
      options = defaultOptions[self.type];
      create(options);
    } else {
      options = {
        level: self.level(),
        radius: self.radius(),
        minSize: self.minSize(),
        maxSize: self.maxSize(),
        minDistance: self.minDistance(),
        maxDistance: self.maxDistance(),
        minCount: self.minCount(),
        maxCount: self.maxCount(),
        color: self.color(),
        useRandomColor: _useRandomColor
      };
    }
    localStorage.setItem(self.type, JSON.stringify(options));
  };

  var defaultOptions = {
    sun: {
      level: 1,
      radius: 25,
      color: '#FDB813'
    },
    planet: {
      level: 2,
      minSize: 10,
      maxSize: 15,
      minDistance: 20,
      maxDistance: 100,
      minCount: 1,
      maxCount: 6
    },
    moon: {
      level: 3,
      minSize: 2,
      maxSize: 7,
      minDistance: 10,
      maxDistance: 30,
      minCount: 0,
      maxCount: 3,
      color: '#d3d3d3'
    }
  };

  var options = localStorage.getItem(self.type) ? JSON.parse(localStorage.getItem(self.type)) : defaultOptions[self.type];
  create(options);

  function create(options) {
    self.level(options.level);
    self.radius(options && options.radius ? parseInt(options.radius, 10) : 0);
    self.minSize(options && options.minSize ? parseInt(options.minSize, 10) : 10);
    self.maxSize = ko.observable(options && options.maxSize ? parseInt(options.maxSize, 10) : 10);
    self.minDistance(options && options.minDistance ? parseInt(options.minDistance, 10) : 10);
    self.maxDistance(options && options.maxDistance ? parseInt(options.maxDistance, 10) : 10);
    self.minCount(options && options.minCount ? parseInt(options.minCount, 10) : 1);
    self.maxCount(options && options.maxCount ? parseInt(options.maxCount, 10) : 1);
    _color = options && options.color ? options.color : null;
    _useRandomColor = options && options.useRandomColor ? options.useRandomColor : _color === null;
  }
}
ko.extenders.numeric = function (target, precision) {
  //create a writable computed observable to intercept writes to our observable
  var result = ko.pureComputed({
    read: target, //always return the original observables value
    write: function write(newValue) {
      var current = target(),
          roundingMultiplier = Math.pow(10, precision),
          newValueAsNum = isNaN(newValue) ? 0 : +newValue,
          valueToWrite = Math.round(newValueAsNum * roundingMultiplier) / roundingMultiplier;

      //only write if it changed
      if (valueToWrite !== current) {
        target(valueToWrite);
      } else {
        //if the rounded value is the same, but a different value was written, force a notification for the current field
        if (newValue !== current) {
          target.notifySubscribers(valueToWrite);
        }
      }
    }
  }).extend({ notify: 'always' });

  //initialize with current value to make sure it is rounded appropriately
  result(target());

  //return the new computed observable
  return result;
};
'use strict';

function SolarSystem(renderer) {
  var self = this;

  self.sunOptions = ko.observable(new OrbitalOptions('sun', renderer));
  self.planetOptions = ko.observable(new OrbitalOptions('planet', renderer));
  self.moonOptions = ko.observable(new OrbitalOptions('moon', renderer));

  var sun, stars;
  var starCount = 500,
      starRadius = 0.5,
      starColor = '#ffffff';
  self.generateSolarSystem = function () {
    sun = new Orbital(null, {
      level: self.sunOptions().level(),
      radius: self.sunOptions().radius(),
      color: self.sunOptions().color()
    });
    sun.setName('The Sun');

    var orbitalOptions = [self.sunOptions(), self.planetOptions(), self.moonOptions()];
    sun.createChildren(orbitalOptions);

    // Create the stars every time as well, in case the view size has changed
    stars = [];
    for (var i = 0; i < starCount; i++) {
      var x = randomInt(renderer.originX, renderer.width);
      var y = randomInt(renderer.originY, renderer.height);
      stars.push({ x: x, y: y });
    }

    // Save the current options
    self.sunOptions().save();
    self.planetOptions().save();
    self.moonOptions().save();
  };
  self.generateSolarSystem();

  self.resetToDefault = function () {
    self.sunOptions().save(true);
    self.planetOptions().save(true);
    self.moonOptions().save(true);
    self.generateSolarSystem();
  };

  renderer.render(function () {
    renderStars();
    sun.update();
    sun.render(renderer);
    renderChildren(renderer, sun);
  });

  function renderStars() {
    for (var i = 0, l = stars.length; i < l; i++) {
      var star = stars[i];
      star.x += 1;
      star.y += 0.5;
      renderer.ellipse(star.x, star.y, starRadius, starColor);

      if (star.x > renderer.width) {
        star.x = renderer.originX;
      }
      if (star.y > renderer.height) {
        star.y = renderer.originY;
      }
    }
  }

  function renderChildren(renderer, orbital) {
    for (var i = 0; i < orbital.children.length; i++) {
      var child = orbital.children[i];
      child.update();
      child.render(renderer, orbital);
      renderChildren(renderer, child);
    }
  }
}