'use strict';

function AstroPicOfDay(service) {
  var self = this;

  self.fromDate = ko.observable(moment().subtract(1, 'M'));
  self.toDate = ko.observable(moment());
  self.loading = ko.observable(true);
  self.loadCount = ko.observable();
  self.apods = ko.observableArray();
  self.rows = ko.observableArray();
  self.error = ko.observable();
  var alertError = $('#alertError');
  var dateFormat = 'YYYY-MM-DD';

  /**
   * Creates the grids for the apods. Should only be called once all APIs have finished (check self.loadCount())
   * @param {*[]} apods - An array of apod objects
   */
  function layoutImages(apods) {
    // Clear the old
    self.rows.removeAll();
    // Sort by date
    self.apods.sort(function (left, right) {
      var leftDate = moment(left.date);
      var rightDate = moment(right.date);
      return leftDate.isSame(rightDate) ? 0 : leftDate.isAfter(rightDate) ? 1 : -1;
    });

    var cols = [];
    for (var i = 1; i <= apods.length; i++) {
      cols.push(apods[i - 1]);
      if (i % 7 === 0) {
        // Create a row of 12
        self.rows.push(cols);
        cols = [];
      }
    }
    if (cols.length > 0) {
      self.rows.push(cols);
    }
    self.loading(false);

    // Toggle the tooltips, need the timeout...
    setTimeout(function () {
      $('[data-toggle="popover"]').popover({
        trigger: 'focus',
        container: 'body'
      });
    }, 500);
  }

  function loadImages() {
    self.apods.removeAll();
    var dayDiff = moment(self.toDate()).diff(moment(self.fromDate()), 'd');
    self.loadCount(dayDiff);
    var fromDate = moment(self.fromDate());
    for (var i = 0; i <= self.loadCount(); i++) {
      var requestDate = fromDate.format(dateFormat);
      service.getApod(requestDate, successCallback, errorCallback);
      fromDate.add(1, 'd');
    }
  }
  loadImages();

  ko.computed(function () {
    var apodCount = self.apods().length;
    if (apodCount >= self.loadCount()) {
      // All images should be ready (might need to update this, in case some of the images could not be loaded)
      layoutImages(self.apods());
    }
  });

  var rawFromDate;
  // Validate the fromDate
  ko.computed(function () {
    var fromDate = moment(self.fromDate());
    if (rawFromDate && rawFromDate.isSame(fromDate, 'day')) {
      // No change, so nothing to do here
      return;
    }
    var monthBefore = moment(self.toDate.peek()).subtract(1, 'M');
    if (fromDate.isBefore(monthBefore, 'day')) {
      showError('Too far in the past!');
      self.fromDate(rawFromDate);
      return;
    }
    var dayBefore = moment(self.toDate.peek()).subtract(1, 'd');
    if (fromDate.isAfter(dayBefore, 'day')) {
      showError('Too far in the future!');
      self.fromDate(rawFromDate);
      return;
    }
    if (rawFromDate) {
      // Don't load images if this is the first time
      loadImages();
    }
    rawFromDate = moment(self.fromDate.peek());
  });
  var rawToDate;
  // Validate the toDate
  ko.computed(function () {
    var toDate = moment(self.toDate());
    if (rawToDate && rawToDate.isSame(toDate, 'day')) {
      // No change, so nothing to do here
      return;
    }
    var monthAfter = moment(self.fromDate.peek()).add(1, 'M');
    if (toDate.isAfter(monthAfter, 'day')) {
      showError('Too far in the future!');
      self.toDate(rawToDate);
      return;
    }
    var dayAfter = moment(self.fromDate.peek()).add(1, 'd');
    if (toDate.isBefore(dayAfter, 'day')) {
      showError('Too far in the past!');
      self.toDate(rawToDate);
      return;
    }
    if (rawToDate) {
      // Don't load images if this is the first time
      loadImages();
    }
    rawToDate = moment(self.toDate.peek());
  });

  function successCallback(apod) {
    self.apods.push(apod);
  }
  function errorCallback(text) {
    showError(text);
  }
  function showError(text) {
    self.error(text);
    alertError.fadeIn('slow');
  }
  self.closeAlertError = function () {
    alertError.fadeOut('slow');
  };
}
'use strict';

function Apod(data) {
  var self = this;

  self.date = data ? data.date : null;
  self.explanation = data ? data.explanation : null;
  self.title = data ? data.title : null;
  self.hdUrl = data && data.hdurl ? data.hdurl : 'null';
  self.url = data && data.url ? data.url : '';
  self.mediaType = data ? data.media_type : null;

  return {
    date: self.date,
    explanation: self.explanation,
    title: self.title,
    hdUrl: self.hdUrl,
    url: self.url,
    mediaType: self.mediaType,
    titleAndDate: self.title + ' (' + self.date + ')'
  };
}
'use strict';

function AstroService() {
  var self = this;

  var apodKey = 'apods';

  /**
   * Gets an Apod, with the callback containing the apod on success, and the errCallback containing a string error message. The apodDate must be a string in the format YYYY-MM-DD.
   */
  self.getApod = function (apodDate, callback, errCallback) {
    // First try and get the image from local storage
    var apod = getApod(apodDate);
    if (apod !== null) {
      callback(apod);
      return;
    }
    requestApod(apodDate, callback, errCallback);
  };

  function requestApod(apodDate, callback, errCallback) {
    fetch('/api/apod?date=' + apodDate).then(function (response) {
      if (!response.ok) {
        response.text().then(function (text) {
          errCallback(text);
        });
        return;
      }
      response.json().then(function (data) {
        var apod = new Apod(data);
        // Save the apod in local storage
        saveApod(apod);
        callback(apod);
      });
    });
  }

  /**
   * Gets an Apod from local storage. The apodDate must be a string in the format YYYY-MM-DD.
   * @param {*string} apodDate 
   */
  function getApod(apodDate) {
    var apodsString = localStorage.getItem(apodKey);
    if (apodsString) {
      var apods = JSON.parse(apodsString);
      return apods[apodDate] ? apods[apodDate] : null;
    }
    return null;
  }

  function saveApod(apod) {
    var apods;
    var apodsString = localStorage.getItem(apodKey);
    if (apodsString) {
      apods = JSON.parse(apodsString);
    }
    if (!apods) {
      apods = {};
    }
    apods[apod.date] = apod;
    localStorage.setItem(apodKey, JSON.stringify(apods));
  }
}
"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

ko.bindingHandlers.dateTimePicker = {
  init: function init(element, valueAccessor, allBindingsAccessor) {
    //initialize datepicker with some optional options
    var options = allBindingsAccessor().dateTimePickerOptions || {
      format: 'MMM Do, YYYY',
      icons: {
        time: "fa fa-clock-o",
        date: "fa fa-calendar",
        up: "fa fa-arrow-up",
        down: "fa fa-arrow-down",
        next: "fa fa-arrow-right",
        previous: "fa fa-arrow-left"
      }
    };
    $(element).datetimepicker(options);

    //when a user changes the date, update the view model
    ko.utils.registerEventHandler(element, "dp.change", function (event) {
      var value = valueAccessor();
      if (ko.isObservable(value)) {
        if (event.date != null && !(event.date instanceof Date)) {
          value(event.date.toDate());
        } else {
          value(event.date);
        }
      }
    });

    ko.utils.domNodeDisposal.addDisposeCallback(element, function () {
      var picker = $(element).data("DateTimePicker");
      if (picker) {
        picker.destroy();
      }
    });
  },
  update: function update(element, valueAccessor, allBindings, viewModel, bindingContext) {

    var picker = $(element).data("DateTimePicker");
    //when the view model is updated, update the widget
    if (picker) {
      var koDate = ko.utils.unwrapObservable(valueAccessor());

      //in case return from server datetime i am get in this form for example /Date(93989393)/ then fomat this
      koDate = (typeof koDate === "undefined" ? "undefined" : _typeof(koDate)) !== 'object' ? new Date(parseFloat(koDate.replace(/[^0-9]/g, ''))) : koDate;

      picker.date(koDate);
    }
  }
};
'use strict';

function Renderer() {
  var self = this;
  self.render = ko.observable();
  self.backgroundColor = 'black';

  var canvas = $('#theCanvas')[0],
      canvasContainer = $('#canvasContainer');
  context = canvas.getContext('2d');

  self.originX = 0;
  self.originY = 0;
  self.width = canvasContainer.width();
  self.height = window.innerHeight;
  resizeCanvas();

  function render() {
    try {
      requestAnimationFrame(render);

      // Setup the canvas for translate
      context.save();

      self.originX = -(self.width / 2);
      self.originY = -(self.height / 2);
      context.translate(self.width / 2, self.height / 2);

      // Clear the canvas each frame
      clear();

      // Do the rendering
      if (self.render()) self.render()();

      // Restore after all drawing is done
      context.restore();
    } catch (e) {
      // Swallowing exeptions till I figure a better way to report them
      console.error(e);
    }
  }
  render();

  self.ellipse = function (x, y, radius, color) {
    context.beginPath();
    // Ellipse: void context.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise);
    context.ellipse(x, y, radius, radius, 0, 2 * Math.PI, false);
    context.fillStyle = color;
    context.fill();
  };

  self.polygon = function (points, color, alpha) {
    var polygonPoints = points.slice(0); // Need a copy of the points here
    context.beginPath();
    context.fillStyle = color;

    var firstPoint = polygonPoints[0];
    var separatePoints = [];
    for (var i = 0; i < polygonPoints.length; i++) {
      var point = polygonPoints[i];
      if (i === 0) {
        context.moveTo(point.x, point.y);
      } else {
        if (point.x === firstPoint.x && point.y === firstPoint.y && i < polygonPoints.length - 1) {
          // Need to create a separate polygon for these points
          separatePoints = polygonPoints.splice(i + 1, polygonPoints.length - i);
        }
        context.lineTo(point.x, point.y);
      }
    }

    context.fill();
    context.closePath();

    if (separatePoints.length > 0) self.polygon(separatePoints, color);
  };

  window.addEventListener('resize', resizeCanvas, false);
  function resizeCanvas() {
    self.width = canvasContainer.width();
    self.height = window.innerHeight - 10;

    canvas.width = self.width;
    canvas.height = self.height;
  }

  function clear() {
    context.fillStyle = self.backgroundColor;
    context.fillRect(self.originX, self.originY, self.width, self.height);
  }
}