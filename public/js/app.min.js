'use strict';

var app = angular.module('mcnedward', ['ui.router', 'ui.bootstrap', 'ngAnimate', 'vcRecaptcha']).config(['$stateProvider', '$urlRouterProvider', '$httpProvider', '$locationProvider', function ($stateProvider, $urlRouterProvider, $httpProvider, $locationProvider) {
	'use strict';

	$stateProvider.state('app', {
		url: '/',
		templateUrl: 'core/home.html',
		controller: 'ContactCtrl',
		title: 'Edward McNealy'
	}).state('ii', {
		url: '/inheritance-inquiry/',
		templateUrl: 'ii/ii.html',
		controller: 'IICtrl',
		title: 'Inheritance Inquiry'
	}).state('parser', {
		url: '/parser/',
		templateUrl: 'parser/parser.html',
		controller: 'ParserCtrl',
		title: 'Parser'
	}).state('colorZones', {
		url: '/color-zones/',
		templateUrl: 'colorZones/colorZones.html',
		controller: 'ColorZonesCtrl',
		title: 'Color Zones'
	}).state('bramble', {
		url: '/bramble/',
		templateUrl: 'bramble/bramble.html',
		title: 'Bramble'
	}).state('keepfit', {
		url: '/keepfit/',
		templateUrl: 'keepfit/keepfit.html',
		title: 'KeepFit'
	}).state('blackjack', {
		url: '/blackjack/',
		templateUrl: 'blackjack/blackjack.html',
		controller: 'BlackjackCtrl',
		title: 'Blackjack'
	}).state('numberPrinter', {
		url: '/numberprinter/',
		templateUrl: 'numberPrinter/numberPrinter.html',
		controller: 'NumberPrinterCtrl',
		title: 'Number Printer'
	});

	$urlRouterProvider.otherwise('/');
	$urlRouterProvider.when(/ii/, ['$state', '$match', function ($state, $match) {
		$state.go('ii');
	}]);

	$locationProvider.html5Mode(true);
}]);
'use strict';

angular.module('mcnedward').controller('AppCtrl', ['$rootScope', '$state', '$timeout', '$location', '$anchorScroll', function AppCtrl($rootScope, $state, $timeout, $location, $anchorScroll) {
  'use strict';

  $rootScope.inRoot = true;
  $rootScope.appTitle = "Edward McNealy";

  $rootScope.$on('$stateChangeSuccess', function (event, toState, toParams, fromState, fromParams) {
    $rootScope.appTitle = toState.title && toState.title !== '' ? toState.title : 'Edward McNealy';
    if (fromState.name === 'app') {
      // Scroll up to the top when going away from the main app
      adjustScroll('scrollhere');
    } else {
      adjustScroll(fromState.name);
    }
    if (fromState.name === 'colorZones') {
      // The color zones need to stop rendering since we're no longer on that page
      $rootScope.$broadcast('stopRendering');
    }

    $rootScope.inRoot = toState.name === 'app' || toState.name === '';
    $rootScope.useContainerFluid = toState.name == 'colorZones' || toState.name == 'parser';
    $rootScope.useContainer = !$rootScope.inRoot && !$rootScope.useContainerFluid;

    // Update Google Analytics
    ga('set', 'page', toState.name === 'app' ? '/index.html' : toState.url + '.html');
    ga('send', 'pageview');
  });

  $('#loader').fadeOut(500);

  function adjustScroll(id) {
    if (!id || id === '') return;
    $timeout(function () {
      $('html, body').animate({
        scrollTop: $('#' + id).offset().top + 2
      }, 1);
    });
  }
}]);
'use strict';

/**
 * Created by Edward on 11/8/2014.
 */
angular.module('mcnedward').controller('BlackjackCtrl', ['$rootScope', '$scope', '$window', 'blackjackService', 'playerService', function BlackjackCtrl($rootScope, $scope, $window, blackjackService, playerService) {
	'use strict';

	$scope.player = playerService.getPlayer();
	$scope.dealer = playerService.getDealer();

	$rootScope.$on('busted', function (event, args) {
		var user = args;
		if (user.type == 'player') {
			$scope.message = 'You busted...';
			playerService.userWon('dealer');
		}
		if (user.type == 'dealer') {
			$scope.message = 'Dealer busted! You win!';
			playerService.userWon('player');
		}
		blackjackService.flipCards();
		updateUsers(true);
		toggleOptions(false);
	});
	$rootScope.$on('dealerWon', function () {
		$scope.message = 'Dealer wins...';
		playerService.userWon('dealer');
		updateUsers(true);
		toggleOptions(false);
	});
	$rootScope.$on('playerWon', function () {
		$scope.message = 'You win!';
		playerService.userWon('player');
		updateUsers(true);
		toggleOptions(false);
	});
	$rootScope.$on('push', function () {
		$scope.message = 'Push.';
		updateUsers(true);
		toggleOptions(false);
	});
	$rootScope.$on('21', function (event, args) {
		var user = args;
		if (user.type == 'player') {
			$scope.message = 'You got 21! You win!';
			playerService.userWon('player');
		}
		if (user.type == 'dealer') {
			$scope.message = 'Dealer got 21...';
			playerService.userWon('dealer');
		}
		blackjackService.flipCards();
		updateUsers(true);
		toggleOptions(false);
	});

	for (var x = 0; x < 3; x++) {
		var card = $('<img>');
		if (x == 2) {
			card.attr('src', 'img/blackjack/card/b2fv.png');
			card.attr('id', 'startCard');
			card.addClass('card-img');
		} else {
			card.attr('src', 'img/blackjack/card/b2pl.png');
			card.addClass('card-img');
		}
		$('#startCards').append(card);
	}

	$scope.dealCards = function () {
		$scope.message = '';
		// Remove hidden placeholder cards
		$('.empty-card').css('display', 'none');
		playerService.resetUsers();
		// Reset hit21 every time new deck is dealt
		$rootScope.hit21 = false;
		blackjackService.dealCards();
		if (!$rootScope.hit21) {
			updateUsers();
			toggleOptions(true);
		}
	};

	// Scope functions
	$scope.hitMe = function () {
		blackjackService.hitMe($scope.player);
		updateUsers();
	};
	$scope.stay = function () {
		blackjackService.stay();
		updateUsers();
	};
	$scope.addChip = function (amount) {
		$scope.message = '';
		if ($scope.stopBets) {
			$scope.message = 'You can"t place any more bets now!';
			return;
		}
		if ($scope.player.money < $scope.player.bet + amount) {
			$scope.message = 'You don"t have the money to place that bet!';
			return;
		}
		playerService.addChip(amount);
		updateUsers();
	};
	$scope.clearBet = function () {
		$scope.message = '';
		if ($scope.stopBets) {
			if ($scope.player.bet > 0) $scope.message = 'You can"t back out now!';
			return;
		}
		playerService.clearBet();
	};

	function updateUsers(save) {
		$scope.player = playerService.getPlayer();
		$scope.dealer = playerService.getDealer();
		if (save) {
			saveUsers();
		}
	}
	function saveUsers() {
		playerService.updateUsers([$scope.player, $scope.dealer]);
	}

	function toggleOptions(optionsOn) {
		if (optionsOn) {
			$('#options').show();
			$('#startCards').hide();
			// Disable bets
			$scope.stopBets = true;
		} else {
			$('#options').hide();
			$('#startCards').show();
			// Enable bets
			$scope.stopBets = false;
		}
	}
}]);
'use strict';

/**
 * Created by Edward on 11/24/2014.
 */
angular.module('mcnedward').service('blackjackService', ['$rootScope', 'playerService', function ($rootScope, playerService) {
	'use strict';

	var blackjackService = {};
	var suits = ['clubs', 'spades', 'diamonds', 'hearts'];
	var cards = [];

	function createCard(suit, value) {
		var name, srcName;
		if (value == 1 || value > 10) {
			switch (value) {
				case 1:
					name = 'Ace';
					value = 11;
					break;
				case 11:
					name = 'Jack';
					value = 10;
					break;
				case 12:
					name = 'Queen';
					value = 10;
					break;
				case 13:
					name = 'King';
					value = 10;
					break;
			}
			srcName = suit.substring(0, 1).toLowerCase() + name.substring(0, 1).toLowerCase();
		} else {
			name = value;
			srcName = suit.substring(0, 1).toLowerCase() + value;
		}
		var id = suit + name;
		return {
			suit: suit,
			name: name,
			value: value,
			id: id,
			isFaceDown: false,
			src: 'img/blackjack/card/' + srcName + '.png'
		};
	}

	function createCards() {
		cards = [];
		for (var i = 0; i < suits.length; i++) {
			for (var value = 1; value < 14; value++) {
				var card = createCard(suits[i], value);
				cards.push(card);
			}
		}
	}

	blackjackService.dealCards = function () {
		shuffle();
		//fixDeck();
		for (var x = 0; x < 4; x++) {
			if (x % 2 === 0) {
				dealCard(playerService.getPlayer());
			} else {
				if (x == 3) dealCard(playerService.getDealer(), true);else dealCard(playerService.getDealer());
			}
		}
	};

	function dealCard(user, faceDown) {
		var card = cards[0];
		if (faceDown) card.isFaceDown = faceDown;
		playerService.addCard(user, card);

		cards.splice(cards.indexOf(card), 1);
	}

	blackjackService.hitMe = function (user) {
		dealCard(user);
	};

	blackjackService.stay = function () {
		var dealer = playerService.getDealer();
		for (var x = 0; x < dealer.cards; x++) {
			if (dealer.cards[x].isFaceDown) {
				dealer.cards[x].faceDown = false;
			}
		}
		while (dealer.handValue < 17) {
			dealCard(dealer);
		}
		if (dealer.handValue > 21) {
			$rootScope.$broadcast('dealerBusted');
		} else if (dealer.handValue > playerService.getPlayer().handValue) {
			$rootScope.$broadcast('dealerWon');
		} else if (dealer.handValue == playerService.getPlayer().handValue) {
			$rootScope.$broadcast('push');
		} else {
			$rootScope.$broadcast('playerWon');
		}
		$rootScope.$broadcast('showCards');
	};

	// Fischer-Yates shuffle
	function shuffle() {
		createCards();

		var cardsCopy = [],
		    cardsCount = cards.length,
		    i;

		// While there are still cards in original deck...
		while (cardsCount) {
			// Pick a random card
			i = Math.floor(Math.random() * cards.length);
			var card = cards[i];
			// If not already shuffled, move it to the new array.
			if (i in cards) {
				cardsCopy.push(card);
				delete cards[i];
				cardsCount--;
			}
		}
		cards = cardsCopy;
		return cards;
	}

	function fixDeck() {
		cards.push(createCard('clubs', 1));
		cards.push(createCard('clubs', 1));
		cards.push(createCard('clubs', 10));
		cards.push(createCard('clubs', 9));
		cards.push(createCard('clubs', 1));
		cards.push(createCard('clubs', 7));
		cards.push(createCard('clubs', 10));
		cards.push(createCard('clubs', 9));
	}

	// Spin through dealer's cards and flip any face downs
	blackjackService.flipCards = function () {
		for (var c = 0; c < playerService.getDealer().cards.length; c++) {
			var card = playerService.getDealer().cards[c];
			if (card.isFaceDown) {
				card.isFaceDown = false;
				playerService.getDealer().table.find($('#' + card.id)).attr('src', card.src);
			}
		}
	};

	return blackjackService;
}]);
'use strict';

/**
 * Created by Edward on 11/24/2014.
 */
angular.module('mcnedward').service('playerService', ['$rootScope', function ($rootScope) {
	'use strict';

	var playerService = {},
	    users = {};

	function updateUser(user) {
		users[user.type] = user;
		localStorage.users = JSON.stringify(users);
	}
	function updateUsers(users) {
		for (var i = 0; i < users.length; i++) {
			var user = users[i];
			updateUser(user);
		}
	}

	playerService.getPlayer = function () {
		return users.player;
	};
	playerService.getDealer = function () {
		return users.dealer;
	};
	playerService.resetUsers = function () {
		initUsers();
	};
	// Find the user based on the passed in user's type, then update
	playerService.updateUser = function (user) {
		updateUser(user);
	};
	// Update all playerService
	playerService.updateUsers = function (users) {
		updateUsers(users);
	};
	playerService.addCard = function (user, card) {
		user.cards.push(card);
		user.handValue = user.handValue + card.value;
		if (user.handValue > 21) {
			adjustForAces(user);
		}
		if (user.handValue == 21) {
			$rootScope.$broadcast('21', user);
			$rootScope.hit21 = true;
		}
	};
	playerService.addChip = function (amount) {
		users.player.chips['chip' + amount + 's']++;
		users.player.bet = users.player.bet + amount;
		updateUser(users.player);
	};
	playerService.clearBet = function () {
		users.player.bet = 0;
		users.player.chips = getChips();
	};
	playerService.userWon = function (userType) {
		var player = users.player;
		var dealer = users.dealer;
		if (userType == 'player') {
			player.wins = player.wins + 1;
			dealer.loses = dealer.loses + 1;
			player.money += player.bet;
		} else {
			dealer.wins = dealer.wins + 1;
			player.loses = player.loses + 1;
			player.money -= player.bet;
		}
		player.bet = 0;
		player.chips = getChips();
		updateUsers([player, dealer]);
	};

	// Called when service is created, and when a new deck is dealt
	function initUsers() {
		function clearHand(user) {
			user.cards = [];
			user.handValue = 0;
		}
		// Get users from localStorage. This converts their tables back to a jQuery element as well
		function getSavedUsers() {
			var savedUsers = JSON.parse(localStorage.users);
			savedUsers.player.table = $(savedUsers.player.table.selector);
			savedUsers.dealer.table = $(savedUsers.dealer.table.selector);
			return savedUsers;
		}
		// If users already exist, use them
		if (localStorage.users && localStorage.users.length > 2) {
			var savedUsers = getSavedUsers();
			var player = savedUsers.player;
			var dealer = savedUsers.dealer;
			clearHand(player);
			clearHand(dealer);
			updateUsers([player, dealer]);
		} else {
			users.player = {
				table: $('#pTable'),
				cards: [],
				handValue: 0,
				type: 'player',
				money: 1000,
				bet: 0,
				chips: getChips(),
				wins: 0,
				loses: 0
			};
			users.dealer = {
				table: $('#dTable'),
				cards: [],
				handValue: 0,
				type: 'dealer',
				wins: 0,
				loses: 0
			};
			localStorage.users = JSON.stringify(users);
		}
	}
	initUsers();

	function getChips() {
		return {
			chip5s: 0,
			chip10s: 0,
			chip25s: 0,
			chip100s: 0,
			chip500s: 0
		};
	}

	// Check the user's hand for Aces. If there is an ace with the value of 11, change the value to 1
	// If the hand value is over 21 after adjusting, the player busts
	function adjustForAces(user) {
		for (var x = 0; x < user.cards.length; x++) {
			if (user.cards[x].name == 'Ace') {
				// If ace card not already adjusted, fix that
				if (user.cards[x].value == 11) {
					user.cards[x].value = 1;
					updateUserHandValue(user);
				}
				// Stop spinning if hand value less than 21
				if (user.handValue < 21) break;
			}
		}
		if (user.handValue > 21) {
			$rootScope.$broadcast('busted', user);
		}
	}

	function updateUserHandValue(user) {
		var value = 0;
		for (var x = 0; x < user.cards.length; x++) {
			value = value + user.cards[x].value;
		}
		user.handValue = value;
		updateUser(user);
	}

	return playerService;
}]);
'use strict';

/**
 * Created by Edward on 2/19/15.
 */
angular.module('mcnedward').directive('playingCard', function () {
	'use strict';

	return {
		scope: {
			card: '='
		},
		restrict: 'AE',
		replace: 'true',
		controller: function controller($scope) {
			$scope.$on('playerBusted', function () {
				if ($scope.card.isFaceDown) {
					$('#' + $scope.card.id).attr('src', $scope.card.src);
				}
			});
			$scope.$on('showCards', function () {
				$('#' + $scope.card.id).attr('src', $scope.card.src);
			});
		},
		link: function link(scope, element, attrs) {
			if (scope.card.isFaceDown) element.attr('src', 'img/blackjack/card/b2fv.png');else element.attr('src', scope.card.src);
		},
		template: '<img id="{{card.id}}" class="card-img"/>'
	};
});
'use strict';

/**
 * Created by Edward on 10/11/2016.
 */
angular.module('mcnedward').controller('ContactCtrl', ['$scope', function ContactCtrl($scope) {
		'use strict';

		$scope.contactInfo = {};
		$scope.isFormSubmitted = false;
		$scope.contactSuccessMessage = '';
		$scope.contactErrorMessage = '';

		function clear() {
				$scope.contactSuccessMessage = '';
				$scope.contactErrorMessage = '';
		}
		function showError(message) {
				clear();
				$scope.contactErrorMessage = message;
		}

		$scope.submitContact = function (form, contactInfo) {
				if ($scope.isFormSubmitted) return;
				form.$setSubmitted();
				if (form.$invalid) return;
				$scope.isFormSubmitted = true;
				form.$setPristine();
				form.$setUntouched();
				clear();

				var reCaptchaError = 'Sorry, but something went wrong with the reCaptcha. Please refresh the page and try again.';
				if (grecaptcha === null) {
						showError(reCaptchaError);
						return;
				}
				var secretResponse = contactInfo.recaptchaResponse;
				if (secretResponse === null) {
						showError(reCaptchaError);
						return;
				}

				$scope.contactSuccessMessage = 'Sending...';
				var url = '/api/contact?secretResponse=' + secretResponse;
				fetch(url, {
						method: 'POST',
						headers: {
								'Accept': 'application/json',
								'Content-Type': 'application/json'
						},
						body: JSON.stringify(contactInfo)
				}).then(function (response) {
						if (!response.ok) {
								response.text().then(function (text) {
										showError(text);
										$scope.isFormSubmitted = false;
										$scope.$apply();
								});
						} else {
								response.text().then(function (text) {
										$scope.contactSuccessMessage = text;
										$scope.$apply();
										// Trigger Google Analytic event
										ga('send', 'event', 'Contact', 'Email', 'From: ' + contactInfo.email + ' - Subject: ' + contactInfo.subject);
								});
						}
				});
		};

		$scope.checkLength = function (value) {
				var length = value ? value.length : 0;
				if (!length) length = 0;
				return length;
		};
		$scope.emailMaxLength = 100;
		$scope.subjectMaxLength = 100;
		$scope.messageMaxLength = 1000;
		$scope.subjectLength = function () {
				return $scope.checkLength($scope.contactInfo.subject);
		};
		$scope.messageLength = function () {
				return $scope.checkLength($scope.contactInfo.message);
		};
}]);
'use strict';

function ColorPicker() {
  var self = this;

  self.hours = 'hours';
  self.minutes = 'minutes';
  self.seconds = 'seconds';
  self.red = 'red';
  self.green = 'green';
  self.blue = 'blue';
  self.colors = ko.observable({
    red: {
      class: 'btn-danger',
      interval: self.hours
    },
    green: {
      class: 'btn-success',
      interval: self.minutes
    },
    blue: {
      class: 'btn-primary',
      interval: self.seconds
    }
  });
  self.hoursColor = ko.observable(self.colors().red.class);
  self.minutesColor = ko.observable(self.colors().green.class);
  self.secondsColor = ko.observable(self.colors().blue.class);

  self.update = function (intervalName, color) {
    // Update the selected interval observable property (self.hours, self.minutes, self.seconds) and color
    self[intervalName + 'Color'](self.colors()[color].class);

    // Get the original interval's color key
    var originalColorKey;
    for (var key in self.colors()) {
      if (!self.colors().hasOwnProperty(key)) continue;

      if (self.colors()[key].interval === intervalName) {
        originalColorKey = key;
        break;
      }
    }

    var overriden = self.colors()[color];
    self[overriden.interval + 'Color'](self.colors()[originalColorKey].class);

    var temp = self.colors()[color].interval;
    self.colors()[color].interval = intervalName;
    self.colors()[originalColorKey].interval = temp;
  };
}
'use strict';

angular.module('mcnedward').controller('ColorZonesCtrl', ['$rootScope', '$scope', function ColorZonesCtrl($rootScope, $scope) {
  'use strict';

  $(document).ready(function () {
    $scope.renderer = new Renderer();
    var timeZoneService = new TimeZoneService($scope.renderer.width());
    var colorPicker = new ColorPicker();
    var model = new ColorZonesViewModel($scope.renderer, timeZoneService, colorPicker);
    // Figure out why I need this override here...
    ko.options.useOnlyNativeEvents = true;
    ko.applyBindings(model, $('#main')[0]);

    var tooltipService = new TooltipService([{ id: $('#canvasContainer'), timeout: 8 }, { id: $('#hoursControl'), timeout: 3 }, { id: $('#minutesControl'), timeout: 3 }, { id: $('#secondsControl'), timeout: 3 }, { id: $('#opacityControl'), timeout: 4 }, { id: $('#showTimesControl'), timeout: 6 }, { id: $('#showColorsControl'), timeout: 6 }]);
    tooltipService.loadToolips();
  });

  $rootScope.$on('stopRendering', function () {
    $scope.renderer.stopRendering(true);
  });
}]);
'use strict';

var ColorZonesViewModel = function ColorZonesViewModel(renderer, timeZoneService, colorPicker) {
  var self = this;

  var width = renderer.width(),
      height = renderer.height();
  var hoverZoneColor = '#660d60';
  var timeFormat = 'HH:mm:ss';
  var _hoverTimeZoneKey, _hoverRegionKey;
  var _selectedZoneInfo;
  var _mouseX, _mouseY;
  // UI options
  self.colorPicker = ko.observable(colorPicker);
  self.opacity = ko.observable(80);
  self.showTimes = ko.observable(false);
  self.colorAllZones = ko.observable(true);
  // Map options
  self.width = ko.observable(width + 'px');
  self.height = ko.observable(height + 'px');
  self.zoom = ko.observable(1);
  self.centerLat = ko.observable(20);
  self.centerLng = ko.observable(0);
  // Cached zones and regions
  self.timeZones = ko.observableArray();
  self.timeZoneRegions = ko.observable({});

  var _textColor = ko.pureComputed(function () {
    return self.colorAllZones() ? 'white' : 'black';
  });

  // Draw Loop
  renderer.renderFunction(function () {
    if (self.timeZones().length === 0) return;

    var timeTexts = [];
    // Trigger the intervals to draw all the zones
    for (var i = 0; i < self.timeZones().length; i++) {
      var timeZone = self.timeZones()[i];

      var current = moment().tz(timeZone.name);
      var hours = adjustTime(current.hours());
      var minutes = adjustTime(current.minutes());
      var seconds = adjustTime(current.seconds());

      var red = getColorInterval(colorPicker.red, hours, minutes, seconds);
      var green = getColorInterval(colorPicker.green, hours, minutes, seconds);
      var blue = getColorInterval(colorPicker.blue, hours, minutes, seconds);

      var color = "#" + red + green + blue;
      if (self.colorAllZones()) {
        renderer.polygon(timeZone.coords, color, self.opacity());
      }

      if (timeZone.centroidPolygon === undefined) continue;
      var zoneInfo = {
        textX: timeZone.centroidPolygon.centroid.x,
        textY: timeZone.centroidPolygon.centroid.y,
        time: current.format(timeFormat),
        colorHex: color
      };
      timeTexts.push(zoneInfo);
      if (_hoverTimeZoneKey && _hoverTimeZoneKey !== '' && _hoverTimeZoneKey === timeZone.name) {
        _selectedZoneInfo = zoneInfo;
      }
    }

    var hoverTimeZone = self.timeZoneRegions()[_hoverTimeZoneKey];
    if (hoverTimeZone) {
      $.each(hoverTimeZone, function (index, value) {
        if (!value || !value.coords || value.coords.length === 0) return;
        // Use the color-zone hex when only coloring the hover region
        var hoverColor = self.colorAllZones() ? hoverZoneColor : _selectedZoneInfo.colorHex;
        renderer.polygon(value.coords, hoverColor, 80);
      });

      if (!self.showTimes()) {
        renderer.text(_mouseX, _mouseY - 5, _selectedZoneInfo.time, _textColor(), true);
      }
      renderer.text(_mouseX, _mouseY - 25, _hoverRegionKey, _textColor(), true);
      renderer.text(_mouseX, _mouseY - 45, _selectedZoneInfo.colorHex, _textColor(), true);
    }

    // Need to do this in a separate loop here to have the times drawn on top
    if (!self.showTimes()) return;
    for (var j = 0; j < timeTexts.length; j++) {
      renderer.text(timeTexts[j].textX, timeTexts[j].textY, timeTexts[j].time, _textColor());
    }
  });

  var _mapCallback;
  // Load the map image
  function loadMap(mapCallback) {
    _mapCallback = mapCallback;
    fetch('/api/color-zones/map?centerLat=' + self.centerLat() + '&centerLng=' + self.centerLng() + '&zoom=' + self.zoom() + '&width=' + width + '&height=' + height).then(function (response) {
      if (!response.ok) {
        console.error('Something went wrong trying to load the map image...');
        return;
      }
      response.text().then(function (mapUrl) {
        renderer.loadImage(mapUrl);
        if (_mapCallback !== undefined) _mapCallback();
      });
    });
  }
  loadMap();

  // Load the time zones
  timeZoneService.setup(self.centerLat, self.centerLng, self.zoom); // Pass in the observables
  timeZoneService.loadTimeZones(function (errorMessage) {
    console.error(errorMessage);
  }, self.timeZones, self.timeZoneRegions);

  function adjustTime(interval) {
    if (interval < 10) {
      interval = "0" + interval;
    }
    return interval.toString();
  }

  function getColorInterval(color, hours, minutes, seconds) {
    var interval = colorPicker.colors()[color].interval;
    switch (interval) {
      case colorPicker.hours:
        return hours;
      case colorPicker.minutes:
        return minutes;
      case colorPicker.seconds:
        return seconds;
      default:
        console.warn('Could not find an interval for: ' + interval + '...');
    }
  }

  function rayCastTest(points, x, y, zoneName) {
    var rayTest = 0;
    var lastPoint = points[points.length - 1];

    for (var j = 0; j < points.length; j++) {
      var point = points[j];

      if (lastPoint.y <= y && point.y >= y || lastPoint.y > y && point.y < y) {
        var slope = (point.x - lastPoint.x) / (point.y - lastPoint.y);
        var testPoint = slope * (y - lastPoint.y) + lastPoint.x;
        if (testPoint < x) {
          rayTest++;
        }
      }
      lastPoint = point;
    }
    // If the count is odd, we are in the polygon
    return rayTest % 2 === 1;
  }

  renderer.addMouseOverEvent(function (x, y) {
    if (self.timeZones().length === 0) return;

    var found = false;
    for (var i = 0; i < self.timeZones().length; i++) {
      var zone = self.timeZones()[i];
      var boundingBox = zone.boundingBox;
      if (boundingBox === undefined) return;

      // Source: https://github.com/dosx/timezone-picker
      if (y > boundingBox.xyMax.y && y < boundingBox.xyMin.y && x > boundingBox.xyMin.x && x < boundingBox.xyMax.x) {
        // Mouse is in the zone bounds, so now have to check if it is in one of this zone's regions
        var regions = self.timeZoneRegions()[zone.name];
        for (var key in regions) {
          if (!regions.hasOwnProperty(key)) continue;
          if (rayCastTest(regions[key].coords, x, y)) {
            _hoverTimeZoneKey = zone.name;
            _hoverRegionKey = key;
            _mouseX = x;
            _mouseY = y;
            return;
          }
        }
      }
    }
  }, self.centerLat(), self.centerLng());

  renderer.addMouseScrollEvent(function (zoom) {
    if (zoom > 1) {
      self.zoom(self.zoom() + 1);
    } else {
      self.zoom(self.zoom() - 1);
    }

    if (self.zoom() < 1) {
      // Can't zoom any lower
      self.zoom(1);
      return;
    }
  });
};
'use strict';

function Renderer() {
  var self = this;

  var width = 1200,
      height = 700;
  var canvas = $('#theCanvas')[0];
  var context = canvas.getContext('2d');
  var imageBackground;
  var matrix = [1, 0, 0, 1, 0, 0];
  var transformApplied = false;

  // TODO Make color a property here (observable?)
  // Then I can just set the color before calling a drawing function

  self.renderFunction = ko.observable();
  self.stopRendering = ko.observable(false);

  function render() {
    if (self.stopRendering()) return;
    try {
      requestAnimationFrame(render);

      // Clear the canvas each frame
      clear();
      drawImageBackground();

      if (self.renderFunction()) self.renderFunction()();
    } catch (e) {
      // Swallowing exeptions till I figure a better way to report them
    }
  }
  render();

  // Loads a url into an image then draws that image to the canvas
  self.loadImage = function (url) {
    if (imageBackground === undefined) imageBackground = new Image();
    imageBackground.onload = function () {
      // Normally, 0,0 would be the top left of the canvas.
      // I need to translate the canvas and the map image so that the center of the canvas is 0,0
      var centerX = canvas.width / 2;
      var centerY = canvas.height / 2;
      if (!transformApplied) {
        // Save the translate in the matrix
        matrix[4] += matrix[0] * centerX + matrix[2] * centerY;
        matrix[5] += matrix[1] * centerX + matrix[3] * centerY;
        context.translate(centerX, centerY);
        transformApplied = true;
      }
      context.drawImage(imageBackground, centerX * -1, centerY * -1, width, height);
    };
    imageBackground.src = url;
  };

  function drawImageBackground() {
    if (!imageBackground) return;
    var centerX = canvas.width / 2;
    var centerY = canvas.height / 2;
    context.beginPath();
    context.drawImage(imageBackground, centerX * -1, centerY * -1, width, height);
    context.closePath();
  }

  self.ellipse = function (x, y, width, height, color) {
    color = convertHex(color, 100);
    context.beginPath();
    // Ellipse: void context.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise);
    context.ellipse(x, y, width / 2, height / 2, 0, 2 * Math.PI, false);
    context.fillStyle = color;
    context.fill();
  };

  self.polygon = function (points, color, alpha) {
    var polygonPoints = points.slice(0); // Need a copy of the points here
    context.beginPath();
    color = convertHex(color, alpha);
    context.fillStyle = color;

    var firstPoint = polygonPoints[0];
    var separatePoints = [];
    for (var i = 0; i < polygonPoints.length; i++) {
      var point = polygonPoints[i];
      if (i === 0) {
        context.moveTo(point.x, point.y);
      } else {
        if (point.x === firstPoint.x && point.y === firstPoint.y && i < polygonPoints.length - 1) {
          // Need to create a separate polygon for these points
          separatePoints = polygonPoints.splice(i + 1, polygonPoints.length - i);
        }
        context.lineTo(point.x, point.y);
      }
    }

    context.fill();
    context.closePath();

    if (separatePoints.length > 0) self.polygon(separatePoints, color);
  };

  self.text = function (x, y, text, color, centerText) {
    context.font = 'bold 16px Segoe UI';
    context.fillStyle = color;
    if (centerText) {
      var metrics = context.measureText(text);
      x -= metrics.width / 2;
    }
    context.fillText(text, x, y);
  };

  function clear() {
    context.clearRect(0 - canvas.width / 2, 0 - canvas.height / 2, canvas.width, canvas.height);
  }

  self.width = function () {
    return width;
  };

  self.height = function () {
    return height;
  };

  var _mouseOverEvent, _centerLat, _centerLng;
  self.addMouseOverEvent = function (mouseOverEvent, centerLat, centerLng) {
    _mouseOverEvent = mouseOverEvent;
    _centerLat = centerLat;
    _centerLng = centerLng;
    canvas.addEventListener('mousemove', function (event) {
      var rect = canvas.getBoundingClientRect();

      // The canvas uses the center as its (0, 0) point
      var centerX = canvas.width / 2;
      var centerY = canvas.height / 2;

      var x = event.clientX - rect.left - centerX;
      var y = event.clientY - rect.top - centerY;
      _mouseOverEvent(x, y);
    }, false);
  };

  var _scrollCallback;
  self.addMouseScrollEvent = function (callback) {
    _scrollCallback = callback;
    canvas.addEventListener('mousewheel', function () {
      var wheel = event.wheelDelta / 120;
      _scrollCallback(1 + wheel / 2);
    }, false);
  };

  function convertHex(hex, alpha) {
    var r = parseInt(hex.slice(1, 3), 16);
    var g = parseInt(hex.slice(3, 5), 16);
    var b = parseInt(hex.slice(5, 7), 16);
    var a = parseInt(alpha, 16) / 255;
    return 'rgba(' + r + ', ' + g + ', ' + b + ', ' + a + ')';
  }
}
'use strict';

function TimeZoneService(mapWidth) {
  var self = this;

  var mercUnits = mapWidth / 4;

  // This is an observable that the caller passes in
  // It will be updated as the service finishes each of it's requests
  var _timeZonesObservable;
  var _timeZoneRegionsObservable;
  var _centerLat;
  var _centerLng;
  var _zoom;
  var _errorCallback;

  // These need to be observables from ColorZones
  self.setup = function (centerLat, centerLng, zoom) {
    _centerLat = centerLat;
    _centerLng = centerLng;
    _zoom = zoom;
  };

  self.loadTimeZones = function (errorCallback, timeZonesObservable, timeZoneRegionsObservable) {
    _errorCallback = errorCallback;
    if (_centerLat === undefined || _centerLng === undefined || _zoom === undefined) {
      _errorCallback('You need to call TimeZoneService.setCenterCoordinates(centerLat, centerLng, zoom) first!');
      return;
    }
    _timeZonesObservable = timeZonesObservable;
    _timeZoneRegionsObservable = timeZoneRegionsObservable;

    // Load the time zone regions
    fetch('/api/color-zones/hover-regions').then(function (response) {
      if (!response.ok) {
        _errorCallback('Something went wrong trying to load the time zone regions...');
        return;
      }
      response.json().then(function (json) {
        var hoverRegions = JSON.parse(json);

        function getTimeZone(hoverRegion) {
          // Each hover region contains a hover region array of points
          var coords = [];
          for (var i = 0; i < hoverRegion.hoverRegion.length; i++) {
            // Every two points in the hover region are the lat and lng
            var region = hoverRegion.hoverRegion[i];
            for (var j = 0; j < region.points.length; j += 2) {
              var pointPair = region.points.slice(j, j + 2);
              var xy = getXY(pointPair[0], pointPair[1]);
              coords.push(xy);
            }
          }
          return new TimeZone(hoverRegion.name, coords);
        }

        for (var i = 0; i < hoverRegions.length; i++) {
          var timeZone = getTimeZone(hoverRegions[i]);
          loadZonePolygons(timeZone);
          _timeZonesObservable().push(timeZone);
        }

        // All time zones are loaded, so we can now load the bounding boxes
        loadBoundingBoxes();
      });
    });

    self.reloadCoordinates = function () {
      for (var i = 0; i < _timeZonesObservable().length; i++) {
        var coords = _timeZonesObservable()[i].coords;
        for (var j = 0; j < coords.length; j++) {
          coords[j] = getXY(coords[j].x, coords[j].y);
        }
      }
    };

    // Load the bounding boxes
    function loadBoundingBoxes() {
      fetch('/api/color-zones/map-bounds').then(function (response) {
        if (!response.ok) {
          // TODO Handle error here
          return;
        }
        response.json().then(function (json) {
          var boundingBoxes = JSON.parse(json);
          for (var i = 0; i < boundingBoxes.length; i++) {
            var box = boundingBoxes[i];
            for (var j = 0; j < _timeZonesObservable().length; j++) {
              if (_timeZonesObservable()[j].matchesId(box.name)) {
                var xyMin = getXY(box.boundingBox.ymin, box.boundingBox.xmin);
                var xyMax = getXY(box.boundingBox.ymax, box.boundingBox.xmax);
                _timeZonesObservable()[j].boundingBox = {
                  xyMin: xyMin,
                  xyMax: xyMax
                };
                break;
              }
            }
          }
        });
      });
    }

    // Load the polygons for a time zone
    function loadZonePolygons(timeZone) {
      var zoneName = timeZone.name.replace(/\/|_/g, '-');
      fetch('/api/color-zones/polygons/' + zoneName).then(function (response) {
        if (!response.ok) {
          _errorCallback('Something went wrong trying to load the time zone polygons for ' + zoneName + '...');
          return;
        }
        response.json().then(function (json) {
          var data = JSON.parse(json);
          var polygons = {};

          for (var i = 0; i < data.polygons.length; i++) {
            // Loop through all the points in the polygon
            // Every 2 points are a lat & lng pair
            var polygonData = data.polygons[i];
            var coords = [];

            for (var j = 0; j < polygonData.points.length; j += 2) {
              var coord = polygonData.points.slice(j, j + 2);
              var xy = getXY(coord[0], coord[1]);
              coords.push(xy);
            }

            // Check if the polygon has already been created
            var polygon = polygons[polygonData.name];
            if (polygon) {
              polygon.coords = polygon.coords.concat(coords);
            } else {
              polygon = new Polygon(polygonData.name, coords, getXY(polygonData.centroid[1], polygonData.centroid[0]));
              polygons[polygonData.name] = polygon;
            }
          }

          // Check to each polygon to find the largest by seeing if it has the most edges
          // Use the largest polygon's centroid as the timezone centroid
          var centroidName,
              maxPoints = 0;
          $.each(polygons, function (index, value) {
            if (value.coords.length > maxPoints) {
              maxPoints = value.coords.length;
              centroidName = value.name;
            }
          });

          if (!_timeZoneRegionsObservable()[timeZone.name]) {
            _timeZoneRegionsObservable()[timeZone.name] = [];
          }
          _timeZoneRegionsObservable()[timeZone.name] = polygons;
          timeZone.centroidPolygon = polygons[centroidName];
        });
      });
    }
  };

  function getXY(lat, lng) {
    var centerX = mercX(_centerLng());
    var centerY = mercY(_centerLat());
    var x = mercX(lng) - centerX;
    var y = mercY(lat) - centerY;
    return { x: x, y: y };
  }

  function mercX(lng) {
    lng = toRadians(lng);
    var a = mercUnits / Math.PI * Math.pow(2, _zoom());
    var b = lng + Math.PI;
    return a * b;
  }

  function mercY(lat) {
    lat = toRadians(lat);
    var a = mercUnits / Math.PI * Math.pow(2, _zoom());
    var b = Math.tan(Math.PI / 4 + lat / 2);
    var c = Math.PI - Math.log(b);
    return a * c;
  }

  function toRadians(degrees) {
    return degrees * (Math.PI / 180);
  }
}
'use strict';

function TooltipService(tooltips) {
  var self = this;

  var storageKey = 'tooltipsShown';

  self.loadToolips = function () {
    var tooltipsShown = localStorage.getItem(storageKey);
    if (tooltips.length === 0 || tooltipsShown) return;
    showTooltip(0);
  };

  function showTooltip(index) {
    if (index === tooltips.length) return;
    try {
      tooltips[index].id.tooltip('show');
    } catch (e) {}

    setTimeout(function () {
      try {
        tooltips[index].id.tooltip('dispose');
      } catch (e) {}
      // Increment the index to try to get the next tooltip
      index++;
      if (!tooltips[index]) {
        // Don't show the tooltips again
        localStorage.setItem(storageKey, true);
      }
      showTooltip(index);
    }, tooltips[index].timeout * 1000);
  }
}
'use strict';

/**
 * Created by Edward on 10/7/2014.
 */
angular.module('mcnedward').controller('IICtrl', ['$scope', 'modalService', function IICtrl($scope, modalService) {
	'use strict';

	$scope.iiInfo = {};
	$scope.isFormSubmitted = false;

	function showAppError(errorMessage) {
		$scope.showAppError = true;
		$scope.appError = error;
	}
	function showLibError(errorMessage) {
		$scope.showLibError = true;
		$scope.libError = error;
	}
	function clearAppError(errorMessage) {
		$scope.showAppError = false;
		$scope.appError = '';
	}
	function clearLibError(errorMessage) {
		$scope.showLibError = false;
		$scope.libError = '';
	}

	$scope.openDownloadForApp = function () {
		clearAppError();
		modalService.showModal('downloadAppModal');
	};
	$scope.openDownloadForLib = function () {
		clearLibError();
		modalService.showModal('downloadLibModal');
	};

	$scope.downloadIIApp = function (form, iiAppInfo) {
		if ($scope.isAppFormSubmitted) return;
		form.$setSubmitted();
		if (form.$invalid) return;
		$scope.isAppFormSubmitted = true;
		form.$setPristine();
		form.$setUntouched();
		clearAppError();

		var downloadUrl = '/api/ii/app?secretResponse=' + iiAppInfo.recaptchaResponse;
		window.location.href = downloadUrl;
	};
	$scope.downloadIILib = function (form, iiLibInfo) {
		if ($scope.isLibFormSubmitted) return;
		form.$setSubmitted();
		if (form.$invalid) return;
		$scope.isLibFormSubmitted = true;
		form.$setPristine();
		form.$setUntouched();
		clearLibError();

		var downloadUrl = '/api/ii/lib?secretResponse=' + iiLibInfo.recaptchaResponse;
		window.location.href = downloadUrl;
	};
}]);
'use strict';

/**
 * Created by Edward on 11/8/2014.
 */
angular.module('mcnedward').controller('NumberPrinterCtrl', ['$scope', function NumberPrinterCtrl($scope) {
  'use strict';

  $scope.result = '';

  $scope.convertToEnglish = function () {
    convert(function (json) {
      $scope.result = json.englishWord;
      $scope.$apply();
    });
  };

  $scope.convertToRomanNumeral = function () {
    convert(function (json) {
      $scope.result = json.romanNumeral;
      $scope.$apply();
    });
  };

  function convert(callback) {
    clearText();
    var number = $scope.number;
    if (number === '') {
      $scope.errorMessage = 'You need to enter something!';
      return;
    }
    return fetch('/api/number-printer?number=' + number).then(function (response) {
      if (response.ok) {
        response.json().then(callback);
        return;
      }
      response.text().then(function (text) {
        $scope.errorMessage = text;
        $scope.$apply();
      });
    }).catch(function (error) {
      $scope.errorMessage = error;
      $scope.$apply();
    });
  }

  function clearText() {
    $scope.result = '';
    $scope.errorMessage = '';
  }
}]);
'use strict';

/**
 * Created by Edward on 2/28/2016.
 */
angular.module('mcnedward').directive('directory', ['$rootScope', function ($rootScope) {
	'use strict';

	return {
		restrict: 'AE',
		transclude: true,
		scope: {
			name: '=',
			id: '=',
			directories: '=',
			classes: '='
		},
		link: function link(scope, element, attrs) {
			scope.selectClass = function (directoryId, classId) {
				$rootScope.$broadcast('selectClass', {
					directoryId: directoryId,
					classId: classId
				});
			};

			// If there is no name, this is a temporary directory used only for the upload
			scope.isRealDirectory = scope.name !== null && scope.name !== "";
			scope.showContents = false;
		},
		templateUrl: 'parser/directory.html'
	};
}]);
'use strict';

/**
 * Created by Edward on 2/28/2016.
 */
angular.module('mcnedward').directive('dragAndDrop', ['$rootScope', '$timeout', function ($rootScope, $timeout) {
	'use strict';

	return {
		restrict: 'E',
		link: function link(scope, element, attrs) {
			var defaultDragAreaMessage = 'Drag files here!';
			scope.dragAreaMessage = defaultDragAreaMessage;
			scope.dragoverClass = '';
			scope.uploadProgress = 0;

			scope.handleError = function (message, error) {
				scope.fileSelected = false;
				scope.hasError = true;
				scope.load(false);
				scope.dragoverClass = 'dragover-error';
				scope.dragAreaMessage = '';
				scope.dragAreaError = message;
				console.log(error, message);
			};

			var firstTime = true;
			var loading = false;
			scope.load = function (isLoading) {
				scope.dragAreaError = '';
				if (isLoading) {
					loading = true;
					scope.uploadProgress = 0;
					checkProgress();
				} else {
					loading = false;
					if (scope.hasError) return;
					scope.dragAreaMessage = 'Finished!';
					scope.dragoverClass = '';
					scope.uploadProgress = 100;
					$timeout(function () {
						scope.dragAreaMessage = defaultDragAreaMessage;
						scope.uploadProgress = 0;
					}, 3000);
				}
			};
			function checkProgress() {
				// $timeout(function() {
				// 	parserService.getUploadProgress(scope.secretResponse, scope.token).then((response) => {
				//     if (!response.ok) return;

				//     response.text().then((text) => {
				//       scope.uploadProgress = text;
				//       if (loading) {
				//         checkProgress();
				//       }
				//     });
				// 	});
				// }, 300);
			}

			element.bind('dragenter', function (e) {
				e.stopPropagation();
				e.preventDefault();
				e.originalEvent.dataTransfer.dropEffect = 'copy';
				scope.dragoverClass = 'dragover';
				scope.dragAreaMessage = 'Drop files!';
				scope.dragAreaError = '';
				scope.$apply();
			});
			element.bind('dragleave', function (e) {
				e.stopPropagation();
				e.preventDefault();
				scope.dragoverClass = '';
				scope.dragAreaMessage = 'Drag files here!';
				scope.dragAreaError = '';
				scope.$apply();
			});
			element.bind('dragover', function (e) {
				e.stopPropagation();
				e.preventDefault();
				e.originalEvent.dataTransfer.dropEffect = 'copy';
				scope.dragoverClass = 'dragover';
				scope.dragAreaMessage = 'Drop files!';
				scope.dragAreaError = '';
				scope.$apply();
			});
			element.bind('dragevent', function (e) {
				e.stopPropagation();
				e.preventDefault();
			});
			element.bind('drop', function (e) {
				e.stopPropagation();
				e.preventDefault();

				var fileId = 1; // Unique id for identifying the file in the server cache
				var onError = function onError(error) {
					console.log(error);
				};

				function handleDirectory(item, directory, topDirectory) {
					var reader = item.createReader();
					return new Promise(function (resolve) {
						var iterationAttempts = [];
						(function readDirectory(directory, topDirectory) {
							reader.readEntries(function (entries) {
								if (!entries.length) {
									Promise.all(iterationAttempts).then(function (result) {
										// Everything should be done now!
										resolve(topDirectory);
									}, onError);
								} else {
									iterationAttempts.push(Promise.all(entries.map(function (entry) {
										if (entry.isFile) {
											entry.file(function (file) {
												parentDirectory.uploadFiles.push(file);
												// Add the fileId to the file name, to be stripped server-side
												var newFile = new ParserFile(fileId++, file.name);
												directory.files.push(newFile);
												return newFile;
											}, function (e) {
												console.log(e);
											});
										} else {
											var newDirectory = new ParserDirectory(entry.name, [], []);
											// If this is inside a directory, put it in there!
											if (directory) {
												directory.directories.push(newDirectory);
											} else {
												directory = newDirectory;
											}
											return handleDirectory(entry, newDirectory, topDirectory);
										}
									})));
									// Continue reading for more entries
									readDirectory(directory, topDirectory);
								}
							});
						})(directory, topDirectory);
					});
				}

				var event = e.originalEvent;
				if (event) {
					var dataTransfer = event.dataTransfer;
					var items = dataTransfer.items;
					var parentDirectory = new ParserDirectory();
					parentDirectory.uploadFiles = []; // All of the files to upload
					if (items.length == 1) {
						var item = items[0].webkitGetAsEntry();
						if (item.isFile) {
							handleFiles(items);
						} else {
							parentDirectory.name = item.name;
							handleDirectory(item, parentDirectory, parentDirectory).then(function (result) {
								notifyDirectoryDone(result);
							}, onError);
						}
					} else {
						handleFiles(items);
					}
				}

				function handleFiles(items) {
					var webkitItems = [];
					for (var i = 0; i < items.length; i++) {
						webkitItems.push(items[i].webkitGetAsEntry());
					}
					// Need to wrap this in an empty directory
					return new Promise(function (resolve) {
						var iterationAttempts = [];
						iterationAttempts.push(Promise.all(webkitItems.map(function (item) {
							if (item.isFile) {
								return new Promise(function (resolve) {
									item.file(function (file) {
										parentDirectory.uploadFiles.push(file);
										// Add the fileId to the file name, to be stripped server-side
										var newFile = new ParserFile(fileId++, file.name);
										parentDirectory.files.push(newFile);
										resolve(parentDirectory);
										return newFile;
									}, onError);
								});
							} else {
								var newDirectory = new ParserDirectory(item.name, [], []);
								// If this is inside a directory, put it in there!
								if (parentDirectory) {
									parentDirectory.directories.push(newDirectory);
								} else {
									parentDirectory = newDirectory;
								}
								return handleDirectory(item, newDirectory, parentDirectory);
							}
						})));
						Promise.all(iterationAttempts).then(function (result) {
							// Everything should be done now!
							resolve(parentDirectory);
						}, onError);
					}).then(function (result) {
						notifyDirectoryDone(result);
					}, onError);
				}

				function notifyDirectoryDone(file) {
					scope.dragoverClass = 'dropped';
					scope.dragAreaMessage = 'Ready for Upload!';
					scope.$apply();
					scope.filesDropped(file);
				}
			});
		},
		templateUrl: 'parser/fileUpload.html'
	};
}]);
'use strict';

/**
 * Created by Edward on 2/26/2016.
 */

angular.module('mcnedward').controller('ParserCtrl', ['$rootScope', '$scope', '$window', 'parserService', 'recaptchaService', 'modalService', function ParserCtrl($rootScope, $scope, $window, parserService, recaptchaService, modalService) {
  'use strict';

  if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
    modalService.showModal('deviceModal');
  }

  $scope.uploadInfo = {};
  $scope.isFormSubmitted = false;
  $scope.isParsingComplete = false;
  $scope.fileUploadMessage = "Click to choose a Java file or project to parse!";
  $scope.errorMessage = "";
  $scope.fileSelected = false;
  var errorParsingMessage = "Something went wrong parsing files...Please try again.";
  var errorUploadingMessage = "Something went wrong uploading files...Please try again.";

  $('#file-upload').change(function () {
    var files = this.files;
    if (!files || files.length === 0) {
      console.log('No files selected...');
      return;
    }
    var fileName = files[0].name;
    $scope.files = files;

    $scope.fileName = fileName;
    $scope.fileSelected = true;
    $scope.$apply();
  });

  function errorHandler(message, error) {
    var errorMessage = '';
    var data = error && error.data ? error.data : null,
        errors = data && data.errors ? data.errors : [];
    if (errors.length > 0) {
      for (var i = 0; i < errors.length; i++) {
        errorMessage += errors[i];
      }
    } else {
      errorMessage = message;
    }
    $scope.handleError(errorMessage, error);
    $scope.parsingComplete = false;
  }

  function uploadFiles(secretResponse, token) {
    $scope.secretResponse = secretResponse;
    $scope.token = token;

    parserService.uploadFiles($scope.files, secretResponse, token).then(function (response) {
      if (!response.ok) {
        response.text().then(function (text) {
          errorHandler(text);
        });
        return;
      }
      response.json().then(function (uploadResponse) {
        $scope.uploadDirectory.token = uploadResponse.token;
        $scope.uploadDirectory.fileIds = uploadResponse.fileIds;
        try {
          // Send back the uploadResponse along with the directory structure
          // This is when the actual parsing of the files will happen
          parserService.parseFiles($scope.uploadDirectory, secretResponse, token).then(function (response) {
            if (!response.ok) {
              response.text().then(function (text) {
                errorHandler(text);
                return;
              });
            } else {
              $scope.dragAreaMessage = 'Analyzing your files...';
              $scope.$apply();
              response.json().then(function (directoryResponse) {
                parserService.saveDirectory(directoryResponse);

                $scope.load(false);
                $scope.fileSelected = false;
                $scope.isParsingComplete = true;

                $scope.uploadDirectory = {};
                $scope.directory = directoryResponse;
                var classObject = findFirstFileInDirectory(directoryResponse);
                $scope.classObject = classObject;
                styleLineNumbers(classObject);
              });
            }
          }, function (error) {
            errorHandler(errorParsingMessage, error);
          });
        } catch (error) {
          errorHandler(errorParsingMessage, error);
        }
      });
    });
  }

  $scope.uploadFile = function (form, uploadInfo) {
    if ($scope.isFormSubmitted) return;
    form.$setSubmitted();
    if (form.$invalid) return;
    $scope.isFormSubmitted = true;
    form.$setPristine();
    form.$setUntouched();
    $scope.load(true);
    $scope.dragAreaMessage = 'Uploading your files...';
    recaptchaService.verify(uploadInfo.recaptchaResponse, uploadFiles, errorHandler);
  };

  $scope.selectClassObject = function (file) {
    for (var i = 0; i < $scope.classObjects.length; i++) {
      var cObject = $scope.classObjects[i];
      if (cObject.fileName === file.fileName) {
        $scope.classObject = cObject;
      }
      // This should be safe since we should always have the same number of fileNames and classObjects
      $scope.fileNames[i].isSelected = false;
    }
    file.isSelected = true;
    styleLineNumbers($scope.classObject);
  };

  $scope.filesDropped = function (directory) {
    $scope.fileName = directory.name ? directory.name : directory.uploadFiles.length + ' Files';
    $scope.files = directory.uploadFiles;
    $scope.fileSelected = true;
    $scope.uploadDirectory = directory;
    $scope.$apply(); // Need to apply because this is coming from the fileUploadDirective
  };

  $scope.moveToLine = function (content) {
    var lineNumber = content.lineNumber;
    var element = $('#' + lineNumber);
    element.addClass('line-animation-in');
    setTimeout(function () {
      element.addClass('line-animation-out');
      setTimeout(function () {
        element.removeClass('line-animation-in');
        element.removeClass('line-animation-out');
      }, 1500);
    }, 3000);
    $('#classContent').animate({
      scrollTop: element.offset().top - 200
    }, 500);
  };
  $rootScope.$on('selectClass', function (e, args) {
    var classObject = searchDirectory($scope.directory, args.directoryId, args.classId);
    if (classObject) {
      $scope.classObject = classObject;
      styleLineNumbers(classObject);
    } else {
      $scope.errorMessage = 'Could not find class.';
    }
  });
  function searchDirectory(directory, directoryId, classId) {
    var classObject;
    if (directoryId === directory.id) {
      if (directory.classes) {
        classObject = searchClassesInDirectory(directory.classes, classId);
        if (classObject) return classObject;
      }
    }
    for (var i = 0; i < directory.directories.length; i++) {
      var childDirectory = directory.directories[i];
      classObject = searchDirectory(childDirectory, directoryId, classId);
      if (classObject) return classObject;
    }
  }
  function searchClassesInDirectory(classes, classId) {
    for (var i = 0; i < classes.length; i++) {
      var c = classes[i];
      if (c.id == classId) {
        return c;
      }
    }
  }
  function findFirstFileInDirectory(directory) {
    if (directory.classes && directory.classes.length > 0) {
      return directory.classes[0];
    }
    if (directory.directories) {
      for (var i = 0; i < directory.directories.length; i++) {
        classObject = findFirstFileInDirectory(directory.directories[i]);
        if (classObject) return classObject;
      }
    }
    return null;
  }

  // FOR DEBUGGING PURPOSES!
  $scope.directory = parserService.getDirectory();
  if ($scope.directory) {
    $scope.isParsingComplete = true;
    var classObject = findFirstFileInDirectory($scope.directory);
    if (classObject) {
      $scope.classObject = classObject;
      styleLineNumbers(classObject);
    } else {
      $scope.errorMessage = 'Could not find any files in directory ' + $scope.directory.name + '.';
    }
  }

  function setFileNames(classObjects) {
    var fileNames = [];
    angular.forEach(classObjects, function (value, key) {
      fileNames.push({
        fileName: value.fileName,
        isSelected: false
      });
    });
    $scope.fileNames = fileNames;
  }

  // Thanks to: https://jsfiddle.net/tovic/AbpRD/
  function styleLineNumbers(classObject) {
    var pre;
    $('#classContent').empty();
    if (classObject.codeTag) {
      pre = classObject.codeTag;
    } else {
      pre = $('<code/>', {
        id: 'code',
        text: classObject.classContent
      });
      var preLength = pre.length;
      for (var i = 0; i < preLength; i++) {
        pre[i].innerHTML = '<span class="line-number"></span>' + pre[i].innerHTML + '<span class="cl"></span>';
        var num = pre[i].innerHTML.split(/\n/).length;
        for (var j = 0; j < num; j++) {
          var lineNumberElement = pre[i].getElementsByTagName('span')[0];
          var number = j + 1;
          lineNumberElement.innerHTML += '<span id="' + number + '">' + number + '</span>';
        }
      }
      // Cache the code tag to avoid parsing again for multiple selects
      classObject.codeTag = pre;
    }
    pre.appendTo('#classContent');
  }
}]);
"use strict";

function ParserDirectory(name, directories, files) {
	var self = this;
	self.name = name ? name : null;
	self.directories = directories ? directories : [];
	self.files = files ? files : [];
}
"use strict";

function ParserFile(id, name) {
	var self = this;
	self.id = id ? id : 0;
	self.name = name ? name : null;
}
'use strict';

/**
 * Created by Edward on 2/26/2016.
 */
angular.module('mcnedward').service('parserService', ['$http', function ($http) {
	'use strict';

	var parserService = {};

	parserService.uploadFiles = function (files, secretResponse, token) {
		var formData = new FormData();
		angular.forEach(files, function (value, key) {
			formData.append('files', value);
		});

		var url = '/api/parser/files?secretResponse=' + secretResponse + '&requestToken=' + token;
		return fetch(url, {
			method: 'POST',
			body: formData
		});
	};

	parserService.parseFiles = function (directory, secretResponse, token) {
		directory.uploadFiles = null;
		var url = '/api/parser/parse?secretResponse=' + secretResponse + '&requestToken=' + token;
		return fetch(url, {
			method: 'POST',
			headers: {
				'Accept': 'application/json',
				'Content-Type': 'application/json'
			},
			body: JSON.stringify(directory)
		});
	};

	parserService.getUploadProgress = function (secretResponse, token, responseFunction) {
		return fetch('/api/parser/progress?secretResponse=' + secretResponse + '&requestToken=' + token);
	};

	parserService.saveClasses = function (classObjects) {
		if (classObjects) {
			localStorage.classObjects = JSON.stringify(classObjects);
			parserService.classObjects = classObjects;
		} else console.log('No classObjects to save...');
	};
	parserService.getClasses = function () {
		var classObjects = localStorage.classObjects ? JSON.parse(localStorage.classObjects) : null;
		return classObjects;
	};

	parserService.saveDirectory = function (directory) {
		if (directory) {
			localStorage.directory = JSON.stringify(directory);
			parserService.directory = directory;
		} else console.log('No directory to save...');
	};
	parserService.getDirectory = function () {
		var directory = localStorage.directory ? JSON.parse(localStorage.directory) : null;
		return directory;
	};

	return parserService;
}]);
'use strict';

/**
 * Created by Edward on 2/28/2016.
 */

angular.module('mcnedward').directive('structure', ['$rootScope', function ($rootScope) {
	'use strict';

	return {
		restrict: 'E',
		transclude: true,
		scope: {
			title: '@',
			contents: '='
		},
		controller: function controller($scope, $element, $timeout) {},
		link: function link(scope, element, attrs) {},
		templateUrl: 'parser/structure.html'
	};
}]);
'use strict';

/**
 * Created by Edward on 10/18/2014.
 */
angular.module('mcnedward').factory('modalService', ['$timeout', function ($timeout) {
	'use strict';

	var modalService = {};
	var overlay, modal, close;

	function removeModal(hasPerspective) {
		classie.remove(modal, 'md-show');
	}

	function removeModalHandler() {
		removeModal();
	}

	modalService.showModal = function (modalId) {
		modal = document.querySelector('#' + modalId);
		classie.add(modal, 'md-show');

		overlay = document.querySelector('#overlay-' + modalId);
		overlay.removeEventListener('click', removeModalHandler);
		overlay.addEventListener('click', removeModalHandler);

		close = modal.querySelector('.cancel-btn');
		close.addEventListener('click', function (ev) {
			ev.stopPropagation();
			removeModalHandler();
		});
	};
	modalService.closeModal = function () {
		removeModalHandler();
	};
	modalService.isOpen = function () {
		return modal !== undefined;
	};

	function showLoading(show) {
		var loadingDiv = $('#pageLoader');
		if (show) {
			loadingDiv.show();
		} else {
			loadingDiv.hide();
		}
	}

	return modalService;
}]);
'use strict';

/**
 * Created by Edward on 10/15/2016.
 */
angular.module('mcnedward').factory('recaptchaService', function () {
  'use strict';

  var recaptchaService = {};

  recaptchaService.verify = function (secretResponse, successCallback, errorCallback) {
    if (secretResponse === null) {
      errorCallback('Sorry, but something went wrong with the reCaptcha. Please refresh the page and try again.');
      return;
    }
    fetch('/api/recaptcha/verify?secretResponse=' + secretResponse, { method: 'POST' }).then(function (response) {
      var ok = response.ok;
      response.text().then(function (text) {
        if (ok) {
          successCallback(secretResponse, text);
        } else {
          errorCallback(text);
        }
      });
    });
  };

  return recaptchaService;
});
'use strict';

/**
 * Created by Edward on 6/9/2016.
 */
angular.module('mcnedward').factory('userService', [function () {
	'use strict';

	var userService = {};
	var savedUser = null;

	userService.clearCache = function () {
		localStorage.removeItem('user');
		this.savedUser = null;
	};

	userService.isLoggedIn = function () {
		return this.getAuthToken() !== null;
	};

	userService.isAdmin = function () {
		if (!this.savedUser) this.getUser();
		if (this.savedUser.userRoles && this.savedUser.userRoles.indexOf('ADMIN') != -1) return true;else return false;
	};

	userService.save = function (user) {
		if (user && user.authToken !== '') {
			localStorage.user = JSON.stringify(user);
			this.savedUser = user;
		} else {
			console.log('No user to save.');
		}
	};

	userService.update = function () {
		this.save(this.getUser());
	};

	userService.getUser = function () {
		if (!this.savedUser) {
			this.savedUser = localStorage.user ? JSON.parse(localStorage.user) : [];
		}
		return this.savedUser;
	};

	userService.getAuthToken = function () {
		if (!this.savedUser) this.getUser();
		if (this.savedUser.authToken && this.savedUser.authToken !== '') {
			return this.savedUser.authToken;
		} else {
			return null;
		}
	};

	return userService;
}]);
'use strict';

/**
 * Created by Edward on 2/19/15.
 */
angular.module('mcnedward').directive('buttonoptions', [function () {
	'use strict';

	return {
		scope: {
			confirmAction: '&',
			cancelAction: '&'
		},
		restrict: 'AE',
		replace: 'true',
		controller: function controller($scope) {
			$scope.confirm = function () {
				$scope.confirmAction();
			};
			$scope.cancel = function () {
				$scope.cancelAction();
			};
		},
		link: function link(scope, element, attrs) {
			scope.title = attrs.confirmTitle;
			scope.cancelTitle = attrs.cancelTitle ? attrs.cancelTitle : 'X';
			if (attrs.confirmClass) scope.confirmClass = attrs.confirmClass;
		},
		// template: '<div class="button-div"><span id="confirmBtn" class="ebtn ebtn-green confirmBtn" ng-click="confirm()" ng-class="confirmClass" style="width:75%;white-space:nowrap;text-overflow:ellpsis;">{{title}}</span><span class="ebtn ebtn-red cancelBtn" ng-click="cancel()" style="width:25%">{{cancelTitle}}</span></div>'
		template: '<div class="btn-group">' + '<button data-ng-click="confirm()" class="btn ebtn-green">{{title}}</button>' + '<button data-ng-click="cancel()" class="btn ebtn-red cancelBtn">{{cancelTitle}}</button></div>'
	};
}]);
app.directive('ngEnter', function () {
	return function (scope, element, attrs) {
		element.bind('keydown keypress', function (event) {
			if (event.which === 13) {
				scope.$apply(function () {
					scope.$eval(attrs.ngEnter, { 'event': event });
				});
				event.preventDefault();
			}
		});
	};
});
"use strict";

function LatLng(lat, lng) {
  var self = this;
  self.lat = lat;
  self.lng = lng;
}
'use strict';

function Polygon(name, coords, centroid) {
  var self = this;

  self.name = name;
  self.coords = coords;
  self.centroid = centroid;

  self.id = ko.pureComputed(function () {
    return self.name.replace(/\/|_/g, '-');
  });
}
'use strict';

function TimeZone(name, coords) {
  var self = this;

  self.name = name;
  self.coords = coords;
  self.polygons = undefined;
  self.centroidPolygon = undefined;
  self.boundingBox = undefined;

  self.matchesId = function (idToMatch) {
    return self.id() === idToMatch.replace(/\/|_/g, '-');
  };

  self.id = ko.pureComputed(function () {
    return self.name.replace(/\/|_/g, '-');
  });
}
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFwcC5qcyIsImFwcENvbnRyb2xsZXIuanMiLCJibGFja2phY2svYmxhY2tqYWNrQ29udHJvbGxlci5qcyIsImJsYWNramFjay9ibGFja2phY2tTZXJ2aWNlLmpzIiwiYmxhY2tqYWNrL3BsYXllclNlcnZpY2UuanMiLCJibGFja2phY2svcGxheWluZ0NhcmREaXJlY3RpdmUuanMiLCJjb3JlL2NvbnRhY3RDb250cm9sbGVyLmpzIiwiY29sb3Jab25lcy9jb2xvclBpY2tlci5qcyIsImNvbG9yWm9uZXMvY29sb3Jab25lc0NvbnRyb2xsZXIuanMiLCJjb2xvclpvbmVzL2NvbG9yWm9uZXNWaWV3TW9kZWwuanMiLCJjb2xvclpvbmVzL3JlbmRlcmVyLmpzIiwiY29sb3Jab25lcy90aW1lWm9uZVNlcnZpY2UuanMiLCJjb2xvclpvbmVzL3Rvb2x0aXBTZXJ2aWNlLmpzIiwiaWkvaWlDb250cm9sbGVyLmpzIiwibnVtYmVyUHJpbnRlci9udW1iZXJQcmludGVyQ29udHJvbGxlci5qcyIsInBhcnNlci9kaXJlY3RvcnlEaXJlY3RpdmUuanMiLCJwYXJzZXIvZmlsZVVwbG9hZERpcmVjdGl2ZS5qcyIsInBhcnNlci9wYXJzZXJDb250cm9sbGVyLmpzIiwicGFyc2VyL3BhcnNlckRpcmVjdG9yeS5qcyIsInBhcnNlci9wYXJzZXJGaWxlLmpzIiwicGFyc2VyL3BhcnNlclNlcnZpY2UuanMiLCJwYXJzZXIvc3RydWN0dXJlRGlyZWN0aXZlLmpzIiwic2VydmljZXMvbW9kYWxTZXJ2aWNlLmpzIiwic2VydmljZXMvcmVjYXB0Y2hhU2VydmljZS5qcyIsInNlcnZpY2VzL3VzZXJTZXJ2aWNlLmpzIiwidXRpbHMvYnV0dG9uT3B0aW9uc0RpcmVjdGl2ZS5qcyIsImNvbG9yWm9uZXMvbW9kZWxzL2xhdExuZy5qcyIsImNvbG9yWm9uZXMvbW9kZWxzL3BvbHlnb24uanMiLCJjb2xvclpvbmVzL21vZGVscy90aW1lWm9uZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUMzSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDeEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2pLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2xNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzVKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDeExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDck5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDblBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImFwcC5taW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBhcHAgPSBhbmd1bGFyLm1vZHVsZSgnbWNuZWR3YXJkJywgWyd1aS5yb3V0ZXInLCAndWkuYm9vdHN0cmFwJywgJ25nQW5pbWF0ZScsICd2Y1JlY2FwdGNoYSddKS5jb25maWcoWyckc3RhdGVQcm92aWRlcicsICckdXJsUm91dGVyUHJvdmlkZXInLCAnJGh0dHBQcm92aWRlcicsICckbG9jYXRpb25Qcm92aWRlcicsIGZ1bmN0aW9uICgkc3RhdGVQcm92aWRlciwgJHVybFJvdXRlclByb3ZpZGVyLCAkaHR0cFByb3ZpZGVyLCAkbG9jYXRpb25Qcm92aWRlcikge1xuXHQndXNlIHN0cmljdCc7XG5cblx0JHN0YXRlUHJvdmlkZXIuc3RhdGUoJ2FwcCcsIHtcblx0XHR1cmw6ICcvJyxcblx0XHR0ZW1wbGF0ZVVybDogJ2NvcmUvaG9tZS5odG1sJyxcblx0XHRjb250cm9sbGVyOiAnQ29udGFjdEN0cmwnLFxuXHRcdHRpdGxlOiAnRWR3YXJkIE1jTmVhbHknXG5cdH0pLnN0YXRlKCdpaScsIHtcblx0XHR1cmw6ICcvaW5oZXJpdGFuY2UtaW5xdWlyeS8nLFxuXHRcdHRlbXBsYXRlVXJsOiAnaWkvaWkuaHRtbCcsXG5cdFx0Y29udHJvbGxlcjogJ0lJQ3RybCcsXG5cdFx0dGl0bGU6ICdJbmhlcml0YW5jZSBJbnF1aXJ5J1xuXHR9KS5zdGF0ZSgncGFyc2VyJywge1xuXHRcdHVybDogJy9wYXJzZXIvJyxcblx0XHR0ZW1wbGF0ZVVybDogJ3BhcnNlci9wYXJzZXIuaHRtbCcsXG5cdFx0Y29udHJvbGxlcjogJ1BhcnNlckN0cmwnLFxuXHRcdHRpdGxlOiAnUGFyc2VyJ1xuXHR9KS5zdGF0ZSgnY29sb3Jab25lcycsIHtcblx0XHR1cmw6ICcvY29sb3Item9uZXMvJyxcblx0XHR0ZW1wbGF0ZVVybDogJ2NvbG9yWm9uZXMvY29sb3Jab25lcy5odG1sJyxcblx0XHRjb250cm9sbGVyOiAnQ29sb3Jab25lc0N0cmwnLFxuXHRcdHRpdGxlOiAnQ29sb3IgWm9uZXMnXG5cdH0pLnN0YXRlKCdicmFtYmxlJywge1xuXHRcdHVybDogJy9icmFtYmxlLycsXG5cdFx0dGVtcGxhdGVVcmw6ICdicmFtYmxlL2JyYW1ibGUuaHRtbCcsXG5cdFx0dGl0bGU6ICdCcmFtYmxlJ1xuXHR9KS5zdGF0ZSgna2VlcGZpdCcsIHtcblx0XHR1cmw6ICcva2VlcGZpdC8nLFxuXHRcdHRlbXBsYXRlVXJsOiAna2VlcGZpdC9rZWVwZml0Lmh0bWwnLFxuXHRcdHRpdGxlOiAnS2VlcEZpdCdcblx0fSkuc3RhdGUoJ2JsYWNramFjaycsIHtcblx0XHR1cmw6ICcvYmxhY2tqYWNrLycsXG5cdFx0dGVtcGxhdGVVcmw6ICdibGFja2phY2svYmxhY2tqYWNrLmh0bWwnLFxuXHRcdGNvbnRyb2xsZXI6ICdCbGFja2phY2tDdHJsJyxcblx0XHR0aXRsZTogJ0JsYWNramFjaydcblx0fSkuc3RhdGUoJ251bWJlclByaW50ZXInLCB7XG5cdFx0dXJsOiAnL251bWJlcnByaW50ZXIvJyxcblx0XHR0ZW1wbGF0ZVVybDogJ251bWJlclByaW50ZXIvbnVtYmVyUHJpbnRlci5odG1sJyxcblx0XHRjb250cm9sbGVyOiAnTnVtYmVyUHJpbnRlckN0cmwnLFxuXHRcdHRpdGxlOiAnTnVtYmVyIFByaW50ZXInXG5cdH0pO1xuXG5cdCR1cmxSb3V0ZXJQcm92aWRlci5vdGhlcndpc2UoJy8nKTtcblx0JHVybFJvdXRlclByb3ZpZGVyLndoZW4oL2lpLywgWyckc3RhdGUnLCAnJG1hdGNoJywgZnVuY3Rpb24gKCRzdGF0ZSwgJG1hdGNoKSB7XG5cdFx0JHN0YXRlLmdvKCdpaScpO1xuXHR9XSk7XG5cblx0JGxvY2F0aW9uUHJvdmlkZXIuaHRtbDVNb2RlKHRydWUpO1xufV0pOyIsIid1c2Ugc3RyaWN0JztcblxuYW5ndWxhci5tb2R1bGUoJ21jbmVkd2FyZCcpLmNvbnRyb2xsZXIoJ0FwcEN0cmwnLCBbJyRyb290U2NvcGUnLCAnJHN0YXRlJywgJyR0aW1lb3V0JywgJyRsb2NhdGlvbicsICckYW5jaG9yU2Nyb2xsJywgZnVuY3Rpb24gQXBwQ3RybCgkcm9vdFNjb3BlLCAkc3RhdGUsICR0aW1lb3V0LCAkbG9jYXRpb24sICRhbmNob3JTY3JvbGwpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gICRyb290U2NvcGUuaW5Sb290ID0gdHJ1ZTtcbiAgJHJvb3RTY29wZS5hcHBUaXRsZSA9IFwiRWR3YXJkIE1jTmVhbHlcIjtcblxuICAkcm9vdFNjb3BlLiRvbignJHN0YXRlQ2hhbmdlU3VjY2VzcycsIGZ1bmN0aW9uIChldmVudCwgdG9TdGF0ZSwgdG9QYXJhbXMsIGZyb21TdGF0ZSwgZnJvbVBhcmFtcykge1xuICAgICRyb290U2NvcGUuYXBwVGl0bGUgPSB0b1N0YXRlLnRpdGxlICYmIHRvU3RhdGUudGl0bGUgIT09ICcnID8gdG9TdGF0ZS50aXRsZSA6ICdFZHdhcmQgTWNOZWFseSc7XG4gICAgaWYgKGZyb21TdGF0ZS5uYW1lID09PSAnYXBwJykge1xuICAgICAgLy8gU2Nyb2xsIHVwIHRvIHRoZSB0b3Agd2hlbiBnb2luZyBhd2F5IGZyb20gdGhlIG1haW4gYXBwXG4gICAgICBhZGp1c3RTY3JvbGwoJ3Njcm9sbGhlcmUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWRqdXN0U2Nyb2xsKGZyb21TdGF0ZS5uYW1lKTtcbiAgICB9XG4gICAgaWYgKGZyb21TdGF0ZS5uYW1lID09PSAnY29sb3Jab25lcycpIHtcbiAgICAgIC8vIFRoZSBjb2xvciB6b25lcyBuZWVkIHRvIHN0b3AgcmVuZGVyaW5nIHNpbmNlIHdlJ3JlIG5vIGxvbmdlciBvbiB0aGF0IHBhZ2VcbiAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnc3RvcFJlbmRlcmluZycpO1xuICAgIH1cblxuICAgICRyb290U2NvcGUuaW5Sb290ID0gdG9TdGF0ZS5uYW1lID09PSAnYXBwJyB8fCB0b1N0YXRlLm5hbWUgPT09ICcnO1xuICAgICRyb290U2NvcGUudXNlQ29udGFpbmVyRmx1aWQgPSB0b1N0YXRlLm5hbWUgPT0gJ2NvbG9yWm9uZXMnIHx8IHRvU3RhdGUubmFtZSA9PSAncGFyc2VyJztcbiAgICAkcm9vdFNjb3BlLnVzZUNvbnRhaW5lciA9ICEkcm9vdFNjb3BlLmluUm9vdCAmJiAhJHJvb3RTY29wZS51c2VDb250YWluZXJGbHVpZDtcblxuICAgIC8vIFVwZGF0ZSBHb29nbGUgQW5hbHl0aWNzXG4gICAgZ2EoJ3NldCcsICdwYWdlJywgdG9TdGF0ZS5uYW1lID09PSAnYXBwJyA/ICcvaW5kZXguaHRtbCcgOiB0b1N0YXRlLnVybCArICcuaHRtbCcpO1xuICAgIGdhKCdzZW5kJywgJ3BhZ2V2aWV3Jyk7XG4gIH0pO1xuXG4gICQoJyNsb2FkZXInKS5mYWRlT3V0KDUwMCk7XG5cbiAgZnVuY3Rpb24gYWRqdXN0U2Nyb2xsKGlkKSB7XG4gICAgaWYgKCFpZCB8fCBpZCA9PT0gJycpIHJldHVybjtcbiAgICAkdGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAkKCdodG1sLCBib2R5JykuYW5pbWF0ZSh7XG4gICAgICAgIHNjcm9sbFRvcDogJCgnIycgKyBpZCkub2Zmc2V0KCkudG9wICsgMlxuICAgICAgfSwgMSk7XG4gICAgfSk7XG4gIH1cbn1dKTsiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxyXG4gKiBDcmVhdGVkIGJ5IEVkd2FyZCBvbiAxMS84LzIwMTQuXHJcbiAqL1xuYW5ndWxhci5tb2R1bGUoJ21jbmVkd2FyZCcpLmNvbnRyb2xsZXIoJ0JsYWNramFja0N0cmwnLCBbJyRyb290U2NvcGUnLCAnJHNjb3BlJywgJyR3aW5kb3cnLCAnYmxhY2tqYWNrU2VydmljZScsICdwbGF5ZXJTZXJ2aWNlJywgZnVuY3Rpb24gQmxhY2tqYWNrQ3RybCgkcm9vdFNjb3BlLCAkc2NvcGUsICR3aW5kb3csIGJsYWNramFja1NlcnZpY2UsIHBsYXllclNlcnZpY2UpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdCRzY29wZS5wbGF5ZXIgPSBwbGF5ZXJTZXJ2aWNlLmdldFBsYXllcigpO1xuXHQkc2NvcGUuZGVhbGVyID0gcGxheWVyU2VydmljZS5nZXREZWFsZXIoKTtcblxuXHQkcm9vdFNjb3BlLiRvbignYnVzdGVkJywgZnVuY3Rpb24gKGV2ZW50LCBhcmdzKSB7XG5cdFx0dmFyIHVzZXIgPSBhcmdzO1xuXHRcdGlmICh1c2VyLnR5cGUgPT0gJ3BsYXllcicpIHtcblx0XHRcdCRzY29wZS5tZXNzYWdlID0gJ1lvdSBidXN0ZWQuLi4nO1xuXHRcdFx0cGxheWVyU2VydmljZS51c2VyV29uKCdkZWFsZXInKTtcblx0XHR9XG5cdFx0aWYgKHVzZXIudHlwZSA9PSAnZGVhbGVyJykge1xuXHRcdFx0JHNjb3BlLm1lc3NhZ2UgPSAnRGVhbGVyIGJ1c3RlZCEgWW91IHdpbiEnO1xuXHRcdFx0cGxheWVyU2VydmljZS51c2VyV29uKCdwbGF5ZXInKTtcblx0XHR9XG5cdFx0YmxhY2tqYWNrU2VydmljZS5mbGlwQ2FyZHMoKTtcblx0XHR1cGRhdGVVc2Vycyh0cnVlKTtcblx0XHR0b2dnbGVPcHRpb25zKGZhbHNlKTtcblx0fSk7XG5cdCRyb290U2NvcGUuJG9uKCdkZWFsZXJXb24nLCBmdW5jdGlvbiAoKSB7XG5cdFx0JHNjb3BlLm1lc3NhZ2UgPSAnRGVhbGVyIHdpbnMuLi4nO1xuXHRcdHBsYXllclNlcnZpY2UudXNlcldvbignZGVhbGVyJyk7XG5cdFx0dXBkYXRlVXNlcnModHJ1ZSk7XG5cdFx0dG9nZ2xlT3B0aW9ucyhmYWxzZSk7XG5cdH0pO1xuXHQkcm9vdFNjb3BlLiRvbigncGxheWVyV29uJywgZnVuY3Rpb24gKCkge1xuXHRcdCRzY29wZS5tZXNzYWdlID0gJ1lvdSB3aW4hJztcblx0XHRwbGF5ZXJTZXJ2aWNlLnVzZXJXb24oJ3BsYXllcicpO1xuXHRcdHVwZGF0ZVVzZXJzKHRydWUpO1xuXHRcdHRvZ2dsZU9wdGlvbnMoZmFsc2UpO1xuXHR9KTtcblx0JHJvb3RTY29wZS4kb24oJ3B1c2gnLCBmdW5jdGlvbiAoKSB7XG5cdFx0JHNjb3BlLm1lc3NhZ2UgPSAnUHVzaC4nO1xuXHRcdHVwZGF0ZVVzZXJzKHRydWUpO1xuXHRcdHRvZ2dsZU9wdGlvbnMoZmFsc2UpO1xuXHR9KTtcblx0JHJvb3RTY29wZS4kb24oJzIxJywgZnVuY3Rpb24gKGV2ZW50LCBhcmdzKSB7XG5cdFx0dmFyIHVzZXIgPSBhcmdzO1xuXHRcdGlmICh1c2VyLnR5cGUgPT0gJ3BsYXllcicpIHtcblx0XHRcdCRzY29wZS5tZXNzYWdlID0gJ1lvdSBnb3QgMjEhIFlvdSB3aW4hJztcblx0XHRcdHBsYXllclNlcnZpY2UudXNlcldvbigncGxheWVyJyk7XG5cdFx0fVxuXHRcdGlmICh1c2VyLnR5cGUgPT0gJ2RlYWxlcicpIHtcblx0XHRcdCRzY29wZS5tZXNzYWdlID0gJ0RlYWxlciBnb3QgMjEuLi4nO1xuXHRcdFx0cGxheWVyU2VydmljZS51c2VyV29uKCdkZWFsZXInKTtcblx0XHR9XG5cdFx0YmxhY2tqYWNrU2VydmljZS5mbGlwQ2FyZHMoKTtcblx0XHR1cGRhdGVVc2Vycyh0cnVlKTtcblx0XHR0b2dnbGVPcHRpb25zKGZhbHNlKTtcblx0fSk7XG5cblx0Zm9yICh2YXIgeCA9IDA7IHggPCAzOyB4KyspIHtcblx0XHR2YXIgY2FyZCA9ICQoJzxpbWc+Jyk7XG5cdFx0aWYgKHggPT0gMikge1xuXHRcdFx0Y2FyZC5hdHRyKCdzcmMnLCAnaW1nL2JsYWNramFjay9jYXJkL2IyZnYucG5nJyk7XG5cdFx0XHRjYXJkLmF0dHIoJ2lkJywgJ3N0YXJ0Q2FyZCcpO1xuXHRcdFx0Y2FyZC5hZGRDbGFzcygnY2FyZC1pbWcnKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y2FyZC5hdHRyKCdzcmMnLCAnaW1nL2JsYWNramFjay9jYXJkL2IycGwucG5nJyk7XG5cdFx0XHRjYXJkLmFkZENsYXNzKCdjYXJkLWltZycpO1xuXHRcdH1cblx0XHQkKCcjc3RhcnRDYXJkcycpLmFwcGVuZChjYXJkKTtcblx0fVxuXG5cdCRzY29wZS5kZWFsQ2FyZHMgPSBmdW5jdGlvbiAoKSB7XG5cdFx0JHNjb3BlLm1lc3NhZ2UgPSAnJztcblx0XHQvLyBSZW1vdmUgaGlkZGVuIHBsYWNlaG9sZGVyIGNhcmRzXG5cdFx0JCgnLmVtcHR5LWNhcmQnKS5jc3MoJ2Rpc3BsYXknLCAnbm9uZScpO1xuXHRcdHBsYXllclNlcnZpY2UucmVzZXRVc2VycygpO1xuXHRcdC8vIFJlc2V0IGhpdDIxIGV2ZXJ5IHRpbWUgbmV3IGRlY2sgaXMgZGVhbHRcblx0XHQkcm9vdFNjb3BlLmhpdDIxID0gZmFsc2U7XG5cdFx0YmxhY2tqYWNrU2VydmljZS5kZWFsQ2FyZHMoKTtcblx0XHRpZiAoISRyb290U2NvcGUuaGl0MjEpIHtcblx0XHRcdHVwZGF0ZVVzZXJzKCk7XG5cdFx0XHR0b2dnbGVPcHRpb25zKHRydWUpO1xuXHRcdH1cblx0fTtcblxuXHQvLyBTY29wZSBmdW5jdGlvbnNcblx0JHNjb3BlLmhpdE1lID0gZnVuY3Rpb24gKCkge1xuXHRcdGJsYWNramFja1NlcnZpY2UuaGl0TWUoJHNjb3BlLnBsYXllcik7XG5cdFx0dXBkYXRlVXNlcnMoKTtcblx0fTtcblx0JHNjb3BlLnN0YXkgPSBmdW5jdGlvbiAoKSB7XG5cdFx0YmxhY2tqYWNrU2VydmljZS5zdGF5KCk7XG5cdFx0dXBkYXRlVXNlcnMoKTtcblx0fTtcblx0JHNjb3BlLmFkZENoaXAgPSBmdW5jdGlvbiAoYW1vdW50KSB7XG5cdFx0JHNjb3BlLm1lc3NhZ2UgPSAnJztcblx0XHRpZiAoJHNjb3BlLnN0b3BCZXRzKSB7XG5cdFx0XHQkc2NvcGUubWVzc2FnZSA9ICdZb3UgY2FuXCJ0IHBsYWNlIGFueSBtb3JlIGJldHMgbm93ISc7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGlmICgkc2NvcGUucGxheWVyLm1vbmV5IDwgJHNjb3BlLnBsYXllci5iZXQgKyBhbW91bnQpIHtcblx0XHRcdCRzY29wZS5tZXNzYWdlID0gJ1lvdSBkb25cInQgaGF2ZSB0aGUgbW9uZXkgdG8gcGxhY2UgdGhhdCBiZXQhJztcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0cGxheWVyU2VydmljZS5hZGRDaGlwKGFtb3VudCk7XG5cdFx0dXBkYXRlVXNlcnMoKTtcblx0fTtcblx0JHNjb3BlLmNsZWFyQmV0ID0gZnVuY3Rpb24gKCkge1xuXHRcdCRzY29wZS5tZXNzYWdlID0gJyc7XG5cdFx0aWYgKCRzY29wZS5zdG9wQmV0cykge1xuXHRcdFx0aWYgKCRzY29wZS5wbGF5ZXIuYmV0ID4gMCkgJHNjb3BlLm1lc3NhZ2UgPSAnWW91IGNhblwidCBiYWNrIG91dCBub3chJztcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0cGxheWVyU2VydmljZS5jbGVhckJldCgpO1xuXHR9O1xuXG5cdGZ1bmN0aW9uIHVwZGF0ZVVzZXJzKHNhdmUpIHtcblx0XHQkc2NvcGUucGxheWVyID0gcGxheWVyU2VydmljZS5nZXRQbGF5ZXIoKTtcblx0XHQkc2NvcGUuZGVhbGVyID0gcGxheWVyU2VydmljZS5nZXREZWFsZXIoKTtcblx0XHRpZiAoc2F2ZSkge1xuXHRcdFx0c2F2ZVVzZXJzKCk7XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHNhdmVVc2VycygpIHtcblx0XHRwbGF5ZXJTZXJ2aWNlLnVwZGF0ZVVzZXJzKFskc2NvcGUucGxheWVyLCAkc2NvcGUuZGVhbGVyXSk7XG5cdH1cblxuXHRmdW5jdGlvbiB0b2dnbGVPcHRpb25zKG9wdGlvbnNPbikge1xuXHRcdGlmIChvcHRpb25zT24pIHtcblx0XHRcdCQoJyNvcHRpb25zJykuc2hvdygpO1xuXHRcdFx0JCgnI3N0YXJ0Q2FyZHMnKS5oaWRlKCk7XG5cdFx0XHQvLyBEaXNhYmxlIGJldHNcblx0XHRcdCRzY29wZS5zdG9wQmV0cyA9IHRydWU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdCQoJyNvcHRpb25zJykuaGlkZSgpO1xuXHRcdFx0JCgnI3N0YXJ0Q2FyZHMnKS5zaG93KCk7XG5cdFx0XHQvLyBFbmFibGUgYmV0c1xuXHRcdFx0JHNjb3BlLnN0b3BCZXRzID0gZmFsc2U7XG5cdFx0fVxuXHR9XG59XSk7IiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcclxuICogQ3JlYXRlZCBieSBFZHdhcmQgb24gMTEvMjQvMjAxNC5cclxuICovXG5hbmd1bGFyLm1vZHVsZSgnbWNuZWR3YXJkJykuc2VydmljZSgnYmxhY2tqYWNrU2VydmljZScsIFsnJHJvb3RTY29wZScsICdwbGF5ZXJTZXJ2aWNlJywgZnVuY3Rpb24gKCRyb290U2NvcGUsIHBsYXllclNlcnZpY2UpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBibGFja2phY2tTZXJ2aWNlID0ge307XG5cdHZhciBzdWl0cyA9IFsnY2x1YnMnLCAnc3BhZGVzJywgJ2RpYW1vbmRzJywgJ2hlYXJ0cyddO1xuXHR2YXIgY2FyZHMgPSBbXTtcblxuXHRmdW5jdGlvbiBjcmVhdGVDYXJkKHN1aXQsIHZhbHVlKSB7XG5cdFx0dmFyIG5hbWUsIHNyY05hbWU7XG5cdFx0aWYgKHZhbHVlID09IDEgfHwgdmFsdWUgPiAxMCkge1xuXHRcdFx0c3dpdGNoICh2YWx1ZSkge1xuXHRcdFx0XHRjYXNlIDE6XG5cdFx0XHRcdFx0bmFtZSA9ICdBY2UnO1xuXHRcdFx0XHRcdHZhbHVlID0gMTE7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgMTE6XG5cdFx0XHRcdFx0bmFtZSA9ICdKYWNrJztcblx0XHRcdFx0XHR2YWx1ZSA9IDEwO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIDEyOlxuXHRcdFx0XHRcdG5hbWUgPSAnUXVlZW4nO1xuXHRcdFx0XHRcdHZhbHVlID0gMTA7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgMTM6XG5cdFx0XHRcdFx0bmFtZSA9ICdLaW5nJztcblx0XHRcdFx0XHR2YWx1ZSA9IDEwO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0c3JjTmFtZSA9IHN1aXQuc3Vic3RyaW5nKDAsIDEpLnRvTG93ZXJDYXNlKCkgKyBuYW1lLnN1YnN0cmluZygwLCAxKS50b0xvd2VyQ2FzZSgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRuYW1lID0gdmFsdWU7XG5cdFx0XHRzcmNOYW1lID0gc3VpdC5zdWJzdHJpbmcoMCwgMSkudG9Mb3dlckNhc2UoKSArIHZhbHVlO1xuXHRcdH1cblx0XHR2YXIgaWQgPSBzdWl0ICsgbmFtZTtcblx0XHRyZXR1cm4ge1xuXHRcdFx0c3VpdDogc3VpdCxcblx0XHRcdG5hbWU6IG5hbWUsXG5cdFx0XHR2YWx1ZTogdmFsdWUsXG5cdFx0XHRpZDogaWQsXG5cdFx0XHRpc0ZhY2VEb3duOiBmYWxzZSxcblx0XHRcdHNyYzogJ2ltZy9ibGFja2phY2svY2FyZC8nICsgc3JjTmFtZSArICcucG5nJ1xuXHRcdH07XG5cdH1cblxuXHRmdW5jdGlvbiBjcmVhdGVDYXJkcygpIHtcblx0XHRjYXJkcyA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3VpdHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGZvciAodmFyIHZhbHVlID0gMTsgdmFsdWUgPCAxNDsgdmFsdWUrKykge1xuXHRcdFx0XHR2YXIgY2FyZCA9IGNyZWF0ZUNhcmQoc3VpdHNbaV0sIHZhbHVlKTtcblx0XHRcdFx0Y2FyZHMucHVzaChjYXJkKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRibGFja2phY2tTZXJ2aWNlLmRlYWxDYXJkcyA9IGZ1bmN0aW9uICgpIHtcblx0XHRzaHVmZmxlKCk7XG5cdFx0Ly9maXhEZWNrKCk7XG5cdFx0Zm9yICh2YXIgeCA9IDA7IHggPCA0OyB4KyspIHtcblx0XHRcdGlmICh4ICUgMiA9PT0gMCkge1xuXHRcdFx0XHRkZWFsQ2FyZChwbGF5ZXJTZXJ2aWNlLmdldFBsYXllcigpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICh4ID09IDMpIGRlYWxDYXJkKHBsYXllclNlcnZpY2UuZ2V0RGVhbGVyKCksIHRydWUpO2Vsc2UgZGVhbENhcmQocGxheWVyU2VydmljZS5nZXREZWFsZXIoKSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdGZ1bmN0aW9uIGRlYWxDYXJkKHVzZXIsIGZhY2VEb3duKSB7XG5cdFx0dmFyIGNhcmQgPSBjYXJkc1swXTtcblx0XHRpZiAoZmFjZURvd24pIGNhcmQuaXNGYWNlRG93biA9IGZhY2VEb3duO1xuXHRcdHBsYXllclNlcnZpY2UuYWRkQ2FyZCh1c2VyLCBjYXJkKTtcblxuXHRcdGNhcmRzLnNwbGljZShjYXJkcy5pbmRleE9mKGNhcmQpLCAxKTtcblx0fVxuXG5cdGJsYWNramFja1NlcnZpY2UuaGl0TWUgPSBmdW5jdGlvbiAodXNlcikge1xuXHRcdGRlYWxDYXJkKHVzZXIpO1xuXHR9O1xuXG5cdGJsYWNramFja1NlcnZpY2Uuc3RheSA9IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZGVhbGVyID0gcGxheWVyU2VydmljZS5nZXREZWFsZXIoKTtcblx0XHRmb3IgKHZhciB4ID0gMDsgeCA8IGRlYWxlci5jYXJkczsgeCsrKSB7XG5cdFx0XHRpZiAoZGVhbGVyLmNhcmRzW3hdLmlzRmFjZURvd24pIHtcblx0XHRcdFx0ZGVhbGVyLmNhcmRzW3hdLmZhY2VEb3duID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHdoaWxlIChkZWFsZXIuaGFuZFZhbHVlIDwgMTcpIHtcblx0XHRcdGRlYWxDYXJkKGRlYWxlcik7XG5cdFx0fVxuXHRcdGlmIChkZWFsZXIuaGFuZFZhbHVlID4gMjEpIHtcblx0XHRcdCRyb290U2NvcGUuJGJyb2FkY2FzdCgnZGVhbGVyQnVzdGVkJyk7XG5cdFx0fSBlbHNlIGlmIChkZWFsZXIuaGFuZFZhbHVlID4gcGxheWVyU2VydmljZS5nZXRQbGF5ZXIoKS5oYW5kVmFsdWUpIHtcblx0XHRcdCRyb290U2NvcGUuJGJyb2FkY2FzdCgnZGVhbGVyV29uJyk7XG5cdFx0fSBlbHNlIGlmIChkZWFsZXIuaGFuZFZhbHVlID09IHBsYXllclNlcnZpY2UuZ2V0UGxheWVyKCkuaGFuZFZhbHVlKSB7XG5cdFx0XHQkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ3B1c2gnKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0JHJvb3RTY29wZS4kYnJvYWRjYXN0KCdwbGF5ZXJXb24nKTtcblx0XHR9XG5cdFx0JHJvb3RTY29wZS4kYnJvYWRjYXN0KCdzaG93Q2FyZHMnKTtcblx0fTtcblxuXHQvLyBGaXNjaGVyLVlhdGVzIHNodWZmbGVcblx0ZnVuY3Rpb24gc2h1ZmZsZSgpIHtcblx0XHRjcmVhdGVDYXJkcygpO1xuXG5cdFx0dmFyIGNhcmRzQ29weSA9IFtdLFxuXHRcdCAgICBjYXJkc0NvdW50ID0gY2FyZHMubGVuZ3RoLFxuXHRcdCAgICBpO1xuXG5cdFx0Ly8gV2hpbGUgdGhlcmUgYXJlIHN0aWxsIGNhcmRzIGluIG9yaWdpbmFsIGRlY2suLi5cblx0XHR3aGlsZSAoY2FyZHNDb3VudCkge1xuXHRcdFx0Ly8gUGljayBhIHJhbmRvbSBjYXJkXG5cdFx0XHRpID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY2FyZHMubGVuZ3RoKTtcblx0XHRcdHZhciBjYXJkID0gY2FyZHNbaV07XG5cdFx0XHQvLyBJZiBub3QgYWxyZWFkeSBzaHVmZmxlZCwgbW92ZSBpdCB0byB0aGUgbmV3IGFycmF5LlxuXHRcdFx0aWYgKGkgaW4gY2FyZHMpIHtcblx0XHRcdFx0Y2FyZHNDb3B5LnB1c2goY2FyZCk7XG5cdFx0XHRcdGRlbGV0ZSBjYXJkc1tpXTtcblx0XHRcdFx0Y2FyZHNDb3VudC0tO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRjYXJkcyA9IGNhcmRzQ29weTtcblx0XHRyZXR1cm4gY2FyZHM7XG5cdH1cblxuXHRmdW5jdGlvbiBmaXhEZWNrKCkge1xuXHRcdGNhcmRzLnB1c2goY3JlYXRlQ2FyZCgnY2x1YnMnLCAxKSk7XG5cdFx0Y2FyZHMucHVzaChjcmVhdGVDYXJkKCdjbHVicycsIDEpKTtcblx0XHRjYXJkcy5wdXNoKGNyZWF0ZUNhcmQoJ2NsdWJzJywgMTApKTtcblx0XHRjYXJkcy5wdXNoKGNyZWF0ZUNhcmQoJ2NsdWJzJywgOSkpO1xuXHRcdGNhcmRzLnB1c2goY3JlYXRlQ2FyZCgnY2x1YnMnLCAxKSk7XG5cdFx0Y2FyZHMucHVzaChjcmVhdGVDYXJkKCdjbHVicycsIDcpKTtcblx0XHRjYXJkcy5wdXNoKGNyZWF0ZUNhcmQoJ2NsdWJzJywgMTApKTtcblx0XHRjYXJkcy5wdXNoKGNyZWF0ZUNhcmQoJ2NsdWJzJywgOSkpO1xuXHR9XG5cblx0Ly8gU3BpbiB0aHJvdWdoIGRlYWxlcidzIGNhcmRzIGFuZCBmbGlwIGFueSBmYWNlIGRvd25zXG5cdGJsYWNramFja1NlcnZpY2UuZmxpcENhcmRzID0gZnVuY3Rpb24gKCkge1xuXHRcdGZvciAodmFyIGMgPSAwOyBjIDwgcGxheWVyU2VydmljZS5nZXREZWFsZXIoKS5jYXJkcy5sZW5ndGg7IGMrKykge1xuXHRcdFx0dmFyIGNhcmQgPSBwbGF5ZXJTZXJ2aWNlLmdldERlYWxlcigpLmNhcmRzW2NdO1xuXHRcdFx0aWYgKGNhcmQuaXNGYWNlRG93bikge1xuXHRcdFx0XHRjYXJkLmlzRmFjZURvd24gPSBmYWxzZTtcblx0XHRcdFx0cGxheWVyU2VydmljZS5nZXREZWFsZXIoKS50YWJsZS5maW5kKCQoJyMnICsgY2FyZC5pZCkpLmF0dHIoJ3NyYycsIGNhcmQuc3JjKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0cmV0dXJuIGJsYWNramFja1NlcnZpY2U7XG59XSk7IiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcclxuICogQ3JlYXRlZCBieSBFZHdhcmQgb24gMTEvMjQvMjAxNC5cclxuICovXG5hbmd1bGFyLm1vZHVsZSgnbWNuZWR3YXJkJykuc2VydmljZSgncGxheWVyU2VydmljZScsIFsnJHJvb3RTY29wZScsIGZ1bmN0aW9uICgkcm9vdFNjb3BlKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgcGxheWVyU2VydmljZSA9IHt9LFxuXHQgICAgdXNlcnMgPSB7fTtcblxuXHRmdW5jdGlvbiB1cGRhdGVVc2VyKHVzZXIpIHtcblx0XHR1c2Vyc1t1c2VyLnR5cGVdID0gdXNlcjtcblx0XHRsb2NhbFN0b3JhZ2UudXNlcnMgPSBKU09OLnN0cmluZ2lmeSh1c2Vycyk7XG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlVXNlcnModXNlcnMpIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHVzZXJzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgdXNlciA9IHVzZXJzW2ldO1xuXHRcdFx0dXBkYXRlVXNlcih1c2VyKTtcblx0XHR9XG5cdH1cblxuXHRwbGF5ZXJTZXJ2aWNlLmdldFBsYXllciA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdXNlcnMucGxheWVyO1xuXHR9O1xuXHRwbGF5ZXJTZXJ2aWNlLmdldERlYWxlciA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdXNlcnMuZGVhbGVyO1xuXHR9O1xuXHRwbGF5ZXJTZXJ2aWNlLnJlc2V0VXNlcnMgPSBmdW5jdGlvbiAoKSB7XG5cdFx0aW5pdFVzZXJzKCk7XG5cdH07XG5cdC8vIEZpbmQgdGhlIHVzZXIgYmFzZWQgb24gdGhlIHBhc3NlZCBpbiB1c2VyJ3MgdHlwZSwgdGhlbiB1cGRhdGVcblx0cGxheWVyU2VydmljZS51cGRhdGVVc2VyID0gZnVuY3Rpb24gKHVzZXIpIHtcblx0XHR1cGRhdGVVc2VyKHVzZXIpO1xuXHR9O1xuXHQvLyBVcGRhdGUgYWxsIHBsYXllclNlcnZpY2Vcblx0cGxheWVyU2VydmljZS51cGRhdGVVc2VycyA9IGZ1bmN0aW9uICh1c2Vycykge1xuXHRcdHVwZGF0ZVVzZXJzKHVzZXJzKTtcblx0fTtcblx0cGxheWVyU2VydmljZS5hZGRDYXJkID0gZnVuY3Rpb24gKHVzZXIsIGNhcmQpIHtcblx0XHR1c2VyLmNhcmRzLnB1c2goY2FyZCk7XG5cdFx0dXNlci5oYW5kVmFsdWUgPSB1c2VyLmhhbmRWYWx1ZSArIGNhcmQudmFsdWU7XG5cdFx0aWYgKHVzZXIuaGFuZFZhbHVlID4gMjEpIHtcblx0XHRcdGFkanVzdEZvckFjZXModXNlcik7XG5cdFx0fVxuXHRcdGlmICh1c2VyLmhhbmRWYWx1ZSA9PSAyMSkge1xuXHRcdFx0JHJvb3RTY29wZS4kYnJvYWRjYXN0KCcyMScsIHVzZXIpO1xuXHRcdFx0JHJvb3RTY29wZS5oaXQyMSA9IHRydWU7XG5cdFx0fVxuXHR9O1xuXHRwbGF5ZXJTZXJ2aWNlLmFkZENoaXAgPSBmdW5jdGlvbiAoYW1vdW50KSB7XG5cdFx0dXNlcnMucGxheWVyLmNoaXBzWydjaGlwJyArIGFtb3VudCArICdzJ10rKztcblx0XHR1c2Vycy5wbGF5ZXIuYmV0ID0gdXNlcnMucGxheWVyLmJldCArIGFtb3VudDtcblx0XHR1cGRhdGVVc2VyKHVzZXJzLnBsYXllcik7XG5cdH07XG5cdHBsYXllclNlcnZpY2UuY2xlYXJCZXQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dXNlcnMucGxheWVyLmJldCA9IDA7XG5cdFx0dXNlcnMucGxheWVyLmNoaXBzID0gZ2V0Q2hpcHMoKTtcblx0fTtcblx0cGxheWVyU2VydmljZS51c2VyV29uID0gZnVuY3Rpb24gKHVzZXJUeXBlKSB7XG5cdFx0dmFyIHBsYXllciA9IHVzZXJzLnBsYXllcjtcblx0XHR2YXIgZGVhbGVyID0gdXNlcnMuZGVhbGVyO1xuXHRcdGlmICh1c2VyVHlwZSA9PSAncGxheWVyJykge1xuXHRcdFx0cGxheWVyLndpbnMgPSBwbGF5ZXIud2lucyArIDE7XG5cdFx0XHRkZWFsZXIubG9zZXMgPSBkZWFsZXIubG9zZXMgKyAxO1xuXHRcdFx0cGxheWVyLm1vbmV5ICs9IHBsYXllci5iZXQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRlYWxlci53aW5zID0gZGVhbGVyLndpbnMgKyAxO1xuXHRcdFx0cGxheWVyLmxvc2VzID0gcGxheWVyLmxvc2VzICsgMTtcblx0XHRcdHBsYXllci5tb25leSAtPSBwbGF5ZXIuYmV0O1xuXHRcdH1cblx0XHRwbGF5ZXIuYmV0ID0gMDtcblx0XHRwbGF5ZXIuY2hpcHMgPSBnZXRDaGlwcygpO1xuXHRcdHVwZGF0ZVVzZXJzKFtwbGF5ZXIsIGRlYWxlcl0pO1xuXHR9O1xuXG5cdC8vIENhbGxlZCB3aGVuIHNlcnZpY2UgaXMgY3JlYXRlZCwgYW5kIHdoZW4gYSBuZXcgZGVjayBpcyBkZWFsdFxuXHRmdW5jdGlvbiBpbml0VXNlcnMoKSB7XG5cdFx0ZnVuY3Rpb24gY2xlYXJIYW5kKHVzZXIpIHtcblx0XHRcdHVzZXIuY2FyZHMgPSBbXTtcblx0XHRcdHVzZXIuaGFuZFZhbHVlID0gMDtcblx0XHR9XG5cdFx0Ly8gR2V0IHVzZXJzIGZyb20gbG9jYWxTdG9yYWdlLiBUaGlzIGNvbnZlcnRzIHRoZWlyIHRhYmxlcyBiYWNrIHRvIGEgalF1ZXJ5IGVsZW1lbnQgYXMgd2VsbFxuXHRcdGZ1bmN0aW9uIGdldFNhdmVkVXNlcnMoKSB7XG5cdFx0XHR2YXIgc2F2ZWRVc2VycyA9IEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLnVzZXJzKTtcblx0XHRcdHNhdmVkVXNlcnMucGxheWVyLnRhYmxlID0gJChzYXZlZFVzZXJzLnBsYXllci50YWJsZS5zZWxlY3Rvcik7XG5cdFx0XHRzYXZlZFVzZXJzLmRlYWxlci50YWJsZSA9ICQoc2F2ZWRVc2Vycy5kZWFsZXIudGFibGUuc2VsZWN0b3IpO1xuXHRcdFx0cmV0dXJuIHNhdmVkVXNlcnM7XG5cdFx0fVxuXHRcdC8vIElmIHVzZXJzIGFscmVhZHkgZXhpc3QsIHVzZSB0aGVtXG5cdFx0aWYgKGxvY2FsU3RvcmFnZS51c2VycyAmJiBsb2NhbFN0b3JhZ2UudXNlcnMubGVuZ3RoID4gMikge1xuXHRcdFx0dmFyIHNhdmVkVXNlcnMgPSBnZXRTYXZlZFVzZXJzKCk7XG5cdFx0XHR2YXIgcGxheWVyID0gc2F2ZWRVc2Vycy5wbGF5ZXI7XG5cdFx0XHR2YXIgZGVhbGVyID0gc2F2ZWRVc2Vycy5kZWFsZXI7XG5cdFx0XHRjbGVhckhhbmQocGxheWVyKTtcblx0XHRcdGNsZWFySGFuZChkZWFsZXIpO1xuXHRcdFx0dXBkYXRlVXNlcnMoW3BsYXllciwgZGVhbGVyXSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHVzZXJzLnBsYXllciA9IHtcblx0XHRcdFx0dGFibGU6ICQoJyNwVGFibGUnKSxcblx0XHRcdFx0Y2FyZHM6IFtdLFxuXHRcdFx0XHRoYW5kVmFsdWU6IDAsXG5cdFx0XHRcdHR5cGU6ICdwbGF5ZXInLFxuXHRcdFx0XHRtb25leTogMTAwMCxcblx0XHRcdFx0YmV0OiAwLFxuXHRcdFx0XHRjaGlwczogZ2V0Q2hpcHMoKSxcblx0XHRcdFx0d2luczogMCxcblx0XHRcdFx0bG9zZXM6IDBcblx0XHRcdH07XG5cdFx0XHR1c2Vycy5kZWFsZXIgPSB7XG5cdFx0XHRcdHRhYmxlOiAkKCcjZFRhYmxlJyksXG5cdFx0XHRcdGNhcmRzOiBbXSxcblx0XHRcdFx0aGFuZFZhbHVlOiAwLFxuXHRcdFx0XHR0eXBlOiAnZGVhbGVyJyxcblx0XHRcdFx0d2luczogMCxcblx0XHRcdFx0bG9zZXM6IDBcblx0XHRcdH07XG5cdFx0XHRsb2NhbFN0b3JhZ2UudXNlcnMgPSBKU09OLnN0cmluZ2lmeSh1c2Vycyk7XG5cdFx0fVxuXHR9XG5cdGluaXRVc2VycygpO1xuXG5cdGZ1bmN0aW9uIGdldENoaXBzKCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRjaGlwNXM6IDAsXG5cdFx0XHRjaGlwMTBzOiAwLFxuXHRcdFx0Y2hpcDI1czogMCxcblx0XHRcdGNoaXAxMDBzOiAwLFxuXHRcdFx0Y2hpcDUwMHM6IDBcblx0XHR9O1xuXHR9XG5cblx0Ly8gQ2hlY2sgdGhlIHVzZXIncyBoYW5kIGZvciBBY2VzLiBJZiB0aGVyZSBpcyBhbiBhY2Ugd2l0aCB0aGUgdmFsdWUgb2YgMTEsIGNoYW5nZSB0aGUgdmFsdWUgdG8gMVxuXHQvLyBJZiB0aGUgaGFuZCB2YWx1ZSBpcyBvdmVyIDIxIGFmdGVyIGFkanVzdGluZywgdGhlIHBsYXllciBidXN0c1xuXHRmdW5jdGlvbiBhZGp1c3RGb3JBY2VzKHVzZXIpIHtcblx0XHRmb3IgKHZhciB4ID0gMDsgeCA8IHVzZXIuY2FyZHMubGVuZ3RoOyB4KyspIHtcblx0XHRcdGlmICh1c2VyLmNhcmRzW3hdLm5hbWUgPT0gJ0FjZScpIHtcblx0XHRcdFx0Ly8gSWYgYWNlIGNhcmQgbm90IGFscmVhZHkgYWRqdXN0ZWQsIGZpeCB0aGF0XG5cdFx0XHRcdGlmICh1c2VyLmNhcmRzW3hdLnZhbHVlID09IDExKSB7XG5cdFx0XHRcdFx0dXNlci5jYXJkc1t4XS52YWx1ZSA9IDE7XG5cdFx0XHRcdFx0dXBkYXRlVXNlckhhbmRWYWx1ZSh1c2VyKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBTdG9wIHNwaW5uaW5nIGlmIGhhbmQgdmFsdWUgbGVzcyB0aGFuIDIxXG5cdFx0XHRcdGlmICh1c2VyLmhhbmRWYWx1ZSA8IDIxKSBicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKHVzZXIuaGFuZFZhbHVlID4gMjEpIHtcblx0XHRcdCRyb290U2NvcGUuJGJyb2FkY2FzdCgnYnVzdGVkJywgdXNlcik7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gdXBkYXRlVXNlckhhbmRWYWx1ZSh1c2VyKSB7XG5cdFx0dmFyIHZhbHVlID0gMDtcblx0XHRmb3IgKHZhciB4ID0gMDsgeCA8IHVzZXIuY2FyZHMubGVuZ3RoOyB4KyspIHtcblx0XHRcdHZhbHVlID0gdmFsdWUgKyB1c2VyLmNhcmRzW3hdLnZhbHVlO1xuXHRcdH1cblx0XHR1c2VyLmhhbmRWYWx1ZSA9IHZhbHVlO1xuXHRcdHVwZGF0ZVVzZXIodXNlcik7XG5cdH1cblxuXHRyZXR1cm4gcGxheWVyU2VydmljZTtcbn1dKTsiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxyXG4gKiBDcmVhdGVkIGJ5IEVkd2FyZCBvbiAyLzE5LzE1LlxyXG4gKi9cbmFuZ3VsYXIubW9kdWxlKCdtY25lZHdhcmQnKS5kaXJlY3RpdmUoJ3BsYXlpbmdDYXJkJywgZnVuY3Rpb24gKCkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0cmV0dXJuIHtcblx0XHRzY29wZToge1xuXHRcdFx0Y2FyZDogJz0nXG5cdFx0fSxcblx0XHRyZXN0cmljdDogJ0FFJyxcblx0XHRyZXBsYWNlOiAndHJ1ZScsXG5cdFx0Y29udHJvbGxlcjogZnVuY3Rpb24gY29udHJvbGxlcigkc2NvcGUpIHtcblx0XHRcdCRzY29wZS4kb24oJ3BsYXllckJ1c3RlZCcsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0aWYgKCRzY29wZS5jYXJkLmlzRmFjZURvd24pIHtcblx0XHRcdFx0XHQkKCcjJyArICRzY29wZS5jYXJkLmlkKS5hdHRyKCdzcmMnLCAkc2NvcGUuY2FyZC5zcmMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRcdCRzY29wZS4kb24oJ3Nob3dDYXJkcycsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0JCgnIycgKyAkc2NvcGUuY2FyZC5pZCkuYXR0cignc3JjJywgJHNjb3BlLmNhcmQuc3JjKTtcblx0XHRcdH0pO1xuXHRcdH0sXG5cdFx0bGluazogZnVuY3Rpb24gbGluayhzY29wZSwgZWxlbWVudCwgYXR0cnMpIHtcblx0XHRcdGlmIChzY29wZS5jYXJkLmlzRmFjZURvd24pIGVsZW1lbnQuYXR0cignc3JjJywgJ2ltZy9ibGFja2phY2svY2FyZC9iMmZ2LnBuZycpO2Vsc2UgZWxlbWVudC5hdHRyKCdzcmMnLCBzY29wZS5jYXJkLnNyYyk7XG5cdFx0fSxcblx0XHR0ZW1wbGF0ZTogJzxpbWcgaWQ9XCJ7e2NhcmQuaWR9fVwiIGNsYXNzPVwiY2FyZC1pbWdcIi8+J1xuXHR9O1xufSk7IiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcclxuICogQ3JlYXRlZCBieSBFZHdhcmQgb24gMTAvMTEvMjAxNi5cclxuICovXG5hbmd1bGFyLm1vZHVsZSgnbWNuZWR3YXJkJykuY29udHJvbGxlcignQ29udGFjdEN0cmwnLCBbJyRzY29wZScsIGZ1bmN0aW9uIENvbnRhY3RDdHJsKCRzY29wZSkge1xuXHRcdCd1c2Ugc3RyaWN0JztcblxuXHRcdCRzY29wZS5jb250YWN0SW5mbyA9IHt9O1xuXHRcdCRzY29wZS5pc0Zvcm1TdWJtaXR0ZWQgPSBmYWxzZTtcblx0XHQkc2NvcGUuY29udGFjdFN1Y2Nlc3NNZXNzYWdlID0gJyc7XG5cdFx0JHNjb3BlLmNvbnRhY3RFcnJvck1lc3NhZ2UgPSAnJztcblxuXHRcdGZ1bmN0aW9uIGNsZWFyKCkge1xuXHRcdFx0XHQkc2NvcGUuY29udGFjdFN1Y2Nlc3NNZXNzYWdlID0gJyc7XG5cdFx0XHRcdCRzY29wZS5jb250YWN0RXJyb3JNZXNzYWdlID0gJyc7XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIHNob3dFcnJvcihtZXNzYWdlKSB7XG5cdFx0XHRcdGNsZWFyKCk7XG5cdFx0XHRcdCRzY29wZS5jb250YWN0RXJyb3JNZXNzYWdlID0gbWVzc2FnZTtcblx0XHR9XG5cblx0XHQkc2NvcGUuc3VibWl0Q29udGFjdCA9IGZ1bmN0aW9uIChmb3JtLCBjb250YWN0SW5mbykge1xuXHRcdFx0XHRpZiAoJHNjb3BlLmlzRm9ybVN1Ym1pdHRlZCkgcmV0dXJuO1xuXHRcdFx0XHRmb3JtLiRzZXRTdWJtaXR0ZWQoKTtcblx0XHRcdFx0aWYgKGZvcm0uJGludmFsaWQpIHJldHVybjtcblx0XHRcdFx0JHNjb3BlLmlzRm9ybVN1Ym1pdHRlZCA9IHRydWU7XG5cdFx0XHRcdGZvcm0uJHNldFByaXN0aW5lKCk7XG5cdFx0XHRcdGZvcm0uJHNldFVudG91Y2hlZCgpO1xuXHRcdFx0XHRjbGVhcigpO1xuXG5cdFx0XHRcdHZhciByZUNhcHRjaGFFcnJvciA9ICdTb3JyeSwgYnV0IHNvbWV0aGluZyB3ZW50IHdyb25nIHdpdGggdGhlIHJlQ2FwdGNoYS4gUGxlYXNlIHJlZnJlc2ggdGhlIHBhZ2UgYW5kIHRyeSBhZ2Fpbi4nO1xuXHRcdFx0XHRpZiAoZ3JlY2FwdGNoYSA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0c2hvd0Vycm9yKHJlQ2FwdGNoYUVycm9yKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgc2VjcmV0UmVzcG9uc2UgPSBjb250YWN0SW5mby5yZWNhcHRjaGFSZXNwb25zZTtcblx0XHRcdFx0aWYgKHNlY3JldFJlc3BvbnNlID09PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRzaG93RXJyb3IocmVDYXB0Y2hhRXJyb3IpO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0JHNjb3BlLmNvbnRhY3RTdWNjZXNzTWVzc2FnZSA9ICdTZW5kaW5nLi4uJztcblx0XHRcdFx0dmFyIHVybCA9ICcvYXBpL2NvbnRhY3Q/c2VjcmV0UmVzcG9uc2U9JyArIHNlY3JldFJlc3BvbnNlO1xuXHRcdFx0XHRmZXRjaCh1cmwsIHtcblx0XHRcdFx0XHRcdG1ldGhvZDogJ1BPU1QnLFxuXHRcdFx0XHRcdFx0aGVhZGVyczoge1xuXHRcdFx0XHRcdFx0XHRcdCdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbicsXG5cdFx0XHRcdFx0XHRcdFx0J0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdGJvZHk6IEpTT04uc3RyaW5naWZ5KGNvbnRhY3RJbmZvKVxuXHRcdFx0XHR9KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuXHRcdFx0XHRcdFx0aWYgKCFyZXNwb25zZS5vaykge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlLnRleHQoKS50aGVuKGZ1bmN0aW9uICh0ZXh0KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHNob3dFcnJvcih0ZXh0KTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0JHNjb3BlLmlzRm9ybVN1Ym1pdHRlZCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHQkc2NvcGUuJGFwcGx5KCk7XG5cdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlLnRleHQoKS50aGVuKGZ1bmN0aW9uICh0ZXh0KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdCRzY29wZS5jb250YWN0U3VjY2Vzc01lc3NhZ2UgPSB0ZXh0O1xuXHRcdFx0XHRcdFx0XHRcdFx0XHQkc2NvcGUuJGFwcGx5KCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFRyaWdnZXIgR29vZ2xlIEFuYWx5dGljIGV2ZW50XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGdhKCdzZW5kJywgJ2V2ZW50JywgJ0NvbnRhY3QnLCAnRW1haWwnLCAnRnJvbTogJyArIGNvbnRhY3RJbmZvLmVtYWlsICsgJyAtIFN1YmplY3Q6ICcgKyBjb250YWN0SW5mby5zdWJqZWN0KTtcblx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0fTtcblxuXHRcdCRzY29wZS5jaGVja0xlbmd0aCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0XHR2YXIgbGVuZ3RoID0gdmFsdWUgPyB2YWx1ZS5sZW5ndGggOiAwO1xuXHRcdFx0XHRpZiAoIWxlbmd0aCkgbGVuZ3RoID0gMDtcblx0XHRcdFx0cmV0dXJuIGxlbmd0aDtcblx0XHR9O1xuXHRcdCRzY29wZS5lbWFpbE1heExlbmd0aCA9IDEwMDtcblx0XHQkc2NvcGUuc3ViamVjdE1heExlbmd0aCA9IDEwMDtcblx0XHQkc2NvcGUubWVzc2FnZU1heExlbmd0aCA9IDEwMDA7XG5cdFx0JHNjb3BlLnN1YmplY3RMZW5ndGggPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHJldHVybiAkc2NvcGUuY2hlY2tMZW5ndGgoJHNjb3BlLmNvbnRhY3RJbmZvLnN1YmplY3QpO1xuXHRcdH07XG5cdFx0JHNjb3BlLm1lc3NhZ2VMZW5ndGggPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHJldHVybiAkc2NvcGUuY2hlY2tMZW5ndGgoJHNjb3BlLmNvbnRhY3RJbmZvLm1lc3NhZ2UpO1xuXHRcdH07XG59XSk7IiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBDb2xvclBpY2tlcigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHNlbGYuaG91cnMgPSAnaG91cnMnO1xuICBzZWxmLm1pbnV0ZXMgPSAnbWludXRlcyc7XG4gIHNlbGYuc2Vjb25kcyA9ICdzZWNvbmRzJztcbiAgc2VsZi5yZWQgPSAncmVkJztcbiAgc2VsZi5ncmVlbiA9ICdncmVlbic7XG4gIHNlbGYuYmx1ZSA9ICdibHVlJztcbiAgc2VsZi5jb2xvcnMgPSBrby5vYnNlcnZhYmxlKHtcbiAgICByZWQ6IHtcbiAgICAgIGNsYXNzOiAnYnRuLWRhbmdlcicsXG4gICAgICBpbnRlcnZhbDogc2VsZi5ob3Vyc1xuICAgIH0sXG4gICAgZ3JlZW46IHtcbiAgICAgIGNsYXNzOiAnYnRuLXN1Y2Nlc3MnLFxuICAgICAgaW50ZXJ2YWw6IHNlbGYubWludXRlc1xuICAgIH0sXG4gICAgYmx1ZToge1xuICAgICAgY2xhc3M6ICdidG4tcHJpbWFyeScsXG4gICAgICBpbnRlcnZhbDogc2VsZi5zZWNvbmRzXG4gICAgfVxuICB9KTtcbiAgc2VsZi5ob3Vyc0NvbG9yID0ga28ub2JzZXJ2YWJsZShzZWxmLmNvbG9ycygpLnJlZC5jbGFzcyk7XG4gIHNlbGYubWludXRlc0NvbG9yID0ga28ub2JzZXJ2YWJsZShzZWxmLmNvbG9ycygpLmdyZWVuLmNsYXNzKTtcbiAgc2VsZi5zZWNvbmRzQ29sb3IgPSBrby5vYnNlcnZhYmxlKHNlbGYuY29sb3JzKCkuYmx1ZS5jbGFzcyk7XG5cbiAgc2VsZi51cGRhdGUgPSBmdW5jdGlvbiAoaW50ZXJ2YWxOYW1lLCBjb2xvcikge1xuICAgIC8vIFVwZGF0ZSB0aGUgc2VsZWN0ZWQgaW50ZXJ2YWwgb2JzZXJ2YWJsZSBwcm9wZXJ0eSAoc2VsZi5ob3Vycywgc2VsZi5taW51dGVzLCBzZWxmLnNlY29uZHMpIGFuZCBjb2xvclxuICAgIHNlbGZbaW50ZXJ2YWxOYW1lICsgJ0NvbG9yJ10oc2VsZi5jb2xvcnMoKVtjb2xvcl0uY2xhc3MpO1xuXG4gICAgLy8gR2V0IHRoZSBvcmlnaW5hbCBpbnRlcnZhbCdzIGNvbG9yIGtleVxuICAgIHZhciBvcmlnaW5hbENvbG9yS2V5O1xuICAgIGZvciAodmFyIGtleSBpbiBzZWxmLmNvbG9ycygpKSB7XG4gICAgICBpZiAoIXNlbGYuY29sb3JzKCkuaGFzT3duUHJvcGVydHkoa2V5KSkgY29udGludWU7XG5cbiAgICAgIGlmIChzZWxmLmNvbG9ycygpW2tleV0uaW50ZXJ2YWwgPT09IGludGVydmFsTmFtZSkge1xuICAgICAgICBvcmlnaW5hbENvbG9yS2V5ID0ga2V5O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgb3ZlcnJpZGVuID0gc2VsZi5jb2xvcnMoKVtjb2xvcl07XG4gICAgc2VsZltvdmVycmlkZW4uaW50ZXJ2YWwgKyAnQ29sb3InXShzZWxmLmNvbG9ycygpW29yaWdpbmFsQ29sb3JLZXldLmNsYXNzKTtcblxuICAgIHZhciB0ZW1wID0gc2VsZi5jb2xvcnMoKVtjb2xvcl0uaW50ZXJ2YWw7XG4gICAgc2VsZi5jb2xvcnMoKVtjb2xvcl0uaW50ZXJ2YWwgPSBpbnRlcnZhbE5hbWU7XG4gICAgc2VsZi5jb2xvcnMoKVtvcmlnaW5hbENvbG9yS2V5XS5pbnRlcnZhbCA9IHRlbXA7XG4gIH07XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG5hbmd1bGFyLm1vZHVsZSgnbWNuZWR3YXJkJykuY29udHJvbGxlcignQ29sb3Jab25lc0N0cmwnLCBbJyRyb290U2NvcGUnLCAnJHNjb3BlJywgZnVuY3Rpb24gQ29sb3Jab25lc0N0cmwoJHJvb3RTY29wZSwgJHNjb3BlKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbiAoKSB7XG4gICAgJHNjb3BlLnJlbmRlcmVyID0gbmV3IFJlbmRlcmVyKCk7XG4gICAgdmFyIHRpbWVab25lU2VydmljZSA9IG5ldyBUaW1lWm9uZVNlcnZpY2UoJHNjb3BlLnJlbmRlcmVyLndpZHRoKCkpO1xuICAgIHZhciBjb2xvclBpY2tlciA9IG5ldyBDb2xvclBpY2tlcigpO1xuICAgIHZhciBtb2RlbCA9IG5ldyBDb2xvclpvbmVzVmlld01vZGVsKCRzY29wZS5yZW5kZXJlciwgdGltZVpvbmVTZXJ2aWNlLCBjb2xvclBpY2tlcik7XG4gICAgLy8gRmlndXJlIG91dCB3aHkgSSBuZWVkIHRoaXMgb3ZlcnJpZGUgaGVyZS4uLlxuICAgIGtvLm9wdGlvbnMudXNlT25seU5hdGl2ZUV2ZW50cyA9IHRydWU7XG4gICAga28uYXBwbHlCaW5kaW5ncyhtb2RlbCwgJCgnI21haW4nKVswXSk7XG5cbiAgICB2YXIgdG9vbHRpcFNlcnZpY2UgPSBuZXcgVG9vbHRpcFNlcnZpY2UoW3sgaWQ6ICQoJyNjYW52YXNDb250YWluZXInKSwgdGltZW91dDogOCB9LCB7IGlkOiAkKCcjaG91cnNDb250cm9sJyksIHRpbWVvdXQ6IDMgfSwgeyBpZDogJCgnI21pbnV0ZXNDb250cm9sJyksIHRpbWVvdXQ6IDMgfSwgeyBpZDogJCgnI3NlY29uZHNDb250cm9sJyksIHRpbWVvdXQ6IDMgfSwgeyBpZDogJCgnI29wYWNpdHlDb250cm9sJyksIHRpbWVvdXQ6IDQgfSwgeyBpZDogJCgnI3Nob3dUaW1lc0NvbnRyb2wnKSwgdGltZW91dDogNiB9LCB7IGlkOiAkKCcjc2hvd0NvbG9yc0NvbnRyb2wnKSwgdGltZW91dDogNiB9XSk7XG4gICAgdG9vbHRpcFNlcnZpY2UubG9hZFRvb2xpcHMoKTtcbiAgfSk7XG5cbiAgJHJvb3RTY29wZS4kb24oJ3N0b3BSZW5kZXJpbmcnLCBmdW5jdGlvbiAoKSB7XG4gICAgJHNjb3BlLnJlbmRlcmVyLnN0b3BSZW5kZXJpbmcodHJ1ZSk7XG4gIH0pO1xufV0pOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIENvbG9yWm9uZXNWaWV3TW9kZWwgPSBmdW5jdGlvbiBDb2xvclpvbmVzVmlld01vZGVsKHJlbmRlcmVyLCB0aW1lWm9uZVNlcnZpY2UsIGNvbG9yUGlja2VyKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB2YXIgd2lkdGggPSByZW5kZXJlci53aWR0aCgpLFxuICAgICAgaGVpZ2h0ID0gcmVuZGVyZXIuaGVpZ2h0KCk7XG4gIHZhciBob3ZlclpvbmVDb2xvciA9ICcjNjYwZDYwJztcbiAgdmFyIHRpbWVGb3JtYXQgPSAnSEg6bW06c3MnO1xuICB2YXIgX2hvdmVyVGltZVpvbmVLZXksIF9ob3ZlclJlZ2lvbktleTtcbiAgdmFyIF9zZWxlY3RlZFpvbmVJbmZvO1xuICB2YXIgX21vdXNlWCwgX21vdXNlWTtcbiAgLy8gVUkgb3B0aW9uc1xuICBzZWxmLmNvbG9yUGlja2VyID0ga28ub2JzZXJ2YWJsZShjb2xvclBpY2tlcik7XG4gIHNlbGYub3BhY2l0eSA9IGtvLm9ic2VydmFibGUoODApO1xuICBzZWxmLnNob3dUaW1lcyA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xuICBzZWxmLmNvbG9yQWxsWm9uZXMgPSBrby5vYnNlcnZhYmxlKHRydWUpO1xuICAvLyBNYXAgb3B0aW9uc1xuICBzZWxmLndpZHRoID0ga28ub2JzZXJ2YWJsZSh3aWR0aCArICdweCcpO1xuICBzZWxmLmhlaWdodCA9IGtvLm9ic2VydmFibGUoaGVpZ2h0ICsgJ3B4Jyk7XG4gIHNlbGYuem9vbSA9IGtvLm9ic2VydmFibGUoMSk7XG4gIHNlbGYuY2VudGVyTGF0ID0ga28ub2JzZXJ2YWJsZSgyMCk7XG4gIHNlbGYuY2VudGVyTG5nID0ga28ub2JzZXJ2YWJsZSgwKTtcbiAgLy8gQ2FjaGVkIHpvbmVzIGFuZCByZWdpb25zXG4gIHNlbGYudGltZVpvbmVzID0ga28ub2JzZXJ2YWJsZUFycmF5KCk7XG4gIHNlbGYudGltZVpvbmVSZWdpb25zID0ga28ub2JzZXJ2YWJsZSh7fSk7XG5cbiAgdmFyIF90ZXh0Q29sb3IgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBzZWxmLmNvbG9yQWxsWm9uZXMoKSA/ICd3aGl0ZScgOiAnYmxhY2snO1xuICB9KTtcblxuICAvLyBEcmF3IExvb3BcbiAgcmVuZGVyZXIucmVuZGVyRnVuY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgIGlmIChzZWxmLnRpbWVab25lcygpLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuXG4gICAgdmFyIHRpbWVUZXh0cyA9IFtdO1xuICAgIC8vIFRyaWdnZXIgdGhlIGludGVydmFscyB0byBkcmF3IGFsbCB0aGUgem9uZXNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYudGltZVpvbmVzKCkubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB0aW1lWm9uZSA9IHNlbGYudGltZVpvbmVzKClbaV07XG5cbiAgICAgIHZhciBjdXJyZW50ID0gbW9tZW50KCkudHoodGltZVpvbmUubmFtZSk7XG4gICAgICB2YXIgaG91cnMgPSBhZGp1c3RUaW1lKGN1cnJlbnQuaG91cnMoKSk7XG4gICAgICB2YXIgbWludXRlcyA9IGFkanVzdFRpbWUoY3VycmVudC5taW51dGVzKCkpO1xuICAgICAgdmFyIHNlY29uZHMgPSBhZGp1c3RUaW1lKGN1cnJlbnQuc2Vjb25kcygpKTtcblxuICAgICAgdmFyIHJlZCA9IGdldENvbG9ySW50ZXJ2YWwoY29sb3JQaWNrZXIucmVkLCBob3VycywgbWludXRlcywgc2Vjb25kcyk7XG4gICAgICB2YXIgZ3JlZW4gPSBnZXRDb2xvckludGVydmFsKGNvbG9yUGlja2VyLmdyZWVuLCBob3VycywgbWludXRlcywgc2Vjb25kcyk7XG4gICAgICB2YXIgYmx1ZSA9IGdldENvbG9ySW50ZXJ2YWwoY29sb3JQaWNrZXIuYmx1ZSwgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMpO1xuXG4gICAgICB2YXIgY29sb3IgPSBcIiNcIiArIHJlZCArIGdyZWVuICsgYmx1ZTtcbiAgICAgIGlmIChzZWxmLmNvbG9yQWxsWm9uZXMoKSkge1xuICAgICAgICByZW5kZXJlci5wb2x5Z29uKHRpbWVab25lLmNvb3JkcywgY29sb3IsIHNlbGYub3BhY2l0eSgpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRpbWVab25lLmNlbnRyb2lkUG9seWdvbiA9PT0gdW5kZWZpbmVkKSBjb250aW51ZTtcbiAgICAgIHZhciB6b25lSW5mbyA9IHtcbiAgICAgICAgdGV4dFg6IHRpbWVab25lLmNlbnRyb2lkUG9seWdvbi5jZW50cm9pZC54LFxuICAgICAgICB0ZXh0WTogdGltZVpvbmUuY2VudHJvaWRQb2x5Z29uLmNlbnRyb2lkLnksXG4gICAgICAgIHRpbWU6IGN1cnJlbnQuZm9ybWF0KHRpbWVGb3JtYXQpLFxuICAgICAgICBjb2xvckhleDogY29sb3JcbiAgICAgIH07XG4gICAgICB0aW1lVGV4dHMucHVzaCh6b25lSW5mbyk7XG4gICAgICBpZiAoX2hvdmVyVGltZVpvbmVLZXkgJiYgX2hvdmVyVGltZVpvbmVLZXkgIT09ICcnICYmIF9ob3ZlclRpbWVab25lS2V5ID09PSB0aW1lWm9uZS5uYW1lKSB7XG4gICAgICAgIF9zZWxlY3RlZFpvbmVJbmZvID0gem9uZUluZm87XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGhvdmVyVGltZVpvbmUgPSBzZWxmLnRpbWVab25lUmVnaW9ucygpW19ob3ZlclRpbWVab25lS2V5XTtcbiAgICBpZiAoaG92ZXJUaW1lWm9uZSkge1xuICAgICAgJC5lYWNoKGhvdmVyVGltZVpvbmUsIGZ1bmN0aW9uIChpbmRleCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKCF2YWx1ZSB8fCAhdmFsdWUuY29vcmRzIHx8IHZhbHVlLmNvb3Jkcy5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICAgICAgLy8gVXNlIHRoZSBjb2xvci16b25lIGhleCB3aGVuIG9ubHkgY29sb3JpbmcgdGhlIGhvdmVyIHJlZ2lvblxuICAgICAgICB2YXIgaG92ZXJDb2xvciA9IHNlbGYuY29sb3JBbGxab25lcygpID8gaG92ZXJab25lQ29sb3IgOiBfc2VsZWN0ZWRab25lSW5mby5jb2xvckhleDtcbiAgICAgICAgcmVuZGVyZXIucG9seWdvbih2YWx1ZS5jb29yZHMsIGhvdmVyQ29sb3IsIDgwKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXNlbGYuc2hvd1RpbWVzKCkpIHtcbiAgICAgICAgcmVuZGVyZXIudGV4dChfbW91c2VYLCBfbW91c2VZIC0gNSwgX3NlbGVjdGVkWm9uZUluZm8udGltZSwgX3RleHRDb2xvcigpLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIHJlbmRlcmVyLnRleHQoX21vdXNlWCwgX21vdXNlWSAtIDI1LCBfaG92ZXJSZWdpb25LZXksIF90ZXh0Q29sb3IoKSwgdHJ1ZSk7XG4gICAgICByZW5kZXJlci50ZXh0KF9tb3VzZVgsIF9tb3VzZVkgLSA0NSwgX3NlbGVjdGVkWm9uZUluZm8uY29sb3JIZXgsIF90ZXh0Q29sb3IoKSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLy8gTmVlZCB0byBkbyB0aGlzIGluIGEgc2VwYXJhdGUgbG9vcCBoZXJlIHRvIGhhdmUgdGhlIHRpbWVzIGRyYXduIG9uIHRvcFxuICAgIGlmICghc2VsZi5zaG93VGltZXMoKSkgcmV0dXJuO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGltZVRleHRzLmxlbmd0aDsgaisrKSB7XG4gICAgICByZW5kZXJlci50ZXh0KHRpbWVUZXh0c1tqXS50ZXh0WCwgdGltZVRleHRzW2pdLnRleHRZLCB0aW1lVGV4dHNbal0udGltZSwgX3RleHRDb2xvcigpKTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBfbWFwQ2FsbGJhY2s7XG4gIC8vIExvYWQgdGhlIG1hcCBpbWFnZVxuICBmdW5jdGlvbiBsb2FkTWFwKG1hcENhbGxiYWNrKSB7XG4gICAgX21hcENhbGxiYWNrID0gbWFwQ2FsbGJhY2s7XG4gICAgZmV0Y2goJy9hcGkvY29sb3Item9uZXMvbWFwP2NlbnRlckxhdD0nICsgc2VsZi5jZW50ZXJMYXQoKSArICcmY2VudGVyTG5nPScgKyBzZWxmLmNlbnRlckxuZygpICsgJyZ6b29tPScgKyBzZWxmLnpvb20oKSArICcmd2lkdGg9JyArIHdpZHRoICsgJyZoZWlnaHQ9JyArIGhlaWdodCkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignU29tZXRoaW5nIHdlbnQgd3JvbmcgdHJ5aW5nIHRvIGxvYWQgdGhlIG1hcCBpbWFnZS4uLicpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXNwb25zZS50ZXh0KCkudGhlbihmdW5jdGlvbiAobWFwVXJsKSB7XG4gICAgICAgIHJlbmRlcmVyLmxvYWRJbWFnZShtYXBVcmwpO1xuICAgICAgICBpZiAoX21hcENhbGxiYWNrICE9PSB1bmRlZmluZWQpIF9tYXBDYWxsYmFjaygpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgbG9hZE1hcCgpO1xuXG4gIC8vIExvYWQgdGhlIHRpbWUgem9uZXNcbiAgdGltZVpvbmVTZXJ2aWNlLnNldHVwKHNlbGYuY2VudGVyTGF0LCBzZWxmLmNlbnRlckxuZywgc2VsZi56b29tKTsgLy8gUGFzcyBpbiB0aGUgb2JzZXJ2YWJsZXNcbiAgdGltZVpvbmVTZXJ2aWNlLmxvYWRUaW1lWm9uZXMoZnVuY3Rpb24gKGVycm9yTWVzc2FnZSkge1xuICAgIGNvbnNvbGUuZXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgfSwgc2VsZi50aW1lWm9uZXMsIHNlbGYudGltZVpvbmVSZWdpb25zKTtcblxuICBmdW5jdGlvbiBhZGp1c3RUaW1lKGludGVydmFsKSB7XG4gICAgaWYgKGludGVydmFsIDwgMTApIHtcbiAgICAgIGludGVydmFsID0gXCIwXCIgKyBpbnRlcnZhbDtcbiAgICB9XG4gICAgcmV0dXJuIGludGVydmFsLnRvU3RyaW5nKCk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRDb2xvckludGVydmFsKGNvbG9yLCBob3VycywgbWludXRlcywgc2Vjb25kcykge1xuICAgIHZhciBpbnRlcnZhbCA9IGNvbG9yUGlja2VyLmNvbG9ycygpW2NvbG9yXS5pbnRlcnZhbDtcbiAgICBzd2l0Y2ggKGludGVydmFsKSB7XG4gICAgICBjYXNlIGNvbG9yUGlja2VyLmhvdXJzOlxuICAgICAgICByZXR1cm4gaG91cnM7XG4gICAgICBjYXNlIGNvbG9yUGlja2VyLm1pbnV0ZXM6XG4gICAgICAgIHJldHVybiBtaW51dGVzO1xuICAgICAgY2FzZSBjb2xvclBpY2tlci5zZWNvbmRzOlxuICAgICAgICByZXR1cm4gc2Vjb25kcztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNvbnNvbGUud2FybignQ291bGQgbm90IGZpbmQgYW4gaW50ZXJ2YWwgZm9yOiAnICsgaW50ZXJ2YWwgKyAnLi4uJyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmF5Q2FzdFRlc3QocG9pbnRzLCB4LCB5LCB6b25lTmFtZSkge1xuICAgIHZhciByYXlUZXN0ID0gMDtcbiAgICB2YXIgbGFzdFBvaW50ID0gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXTtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgcG9pbnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgcG9pbnQgPSBwb2ludHNbal07XG5cbiAgICAgIGlmIChsYXN0UG9pbnQueSA8PSB5ICYmIHBvaW50LnkgPj0geSB8fCBsYXN0UG9pbnQueSA+IHkgJiYgcG9pbnQueSA8IHkpIHtcbiAgICAgICAgdmFyIHNsb3BlID0gKHBvaW50LnggLSBsYXN0UG9pbnQueCkgLyAocG9pbnQueSAtIGxhc3RQb2ludC55KTtcbiAgICAgICAgdmFyIHRlc3RQb2ludCA9IHNsb3BlICogKHkgLSBsYXN0UG9pbnQueSkgKyBsYXN0UG9pbnQueDtcbiAgICAgICAgaWYgKHRlc3RQb2ludCA8IHgpIHtcbiAgICAgICAgICByYXlUZXN0Kys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxhc3RQb2ludCA9IHBvaW50O1xuICAgIH1cbiAgICAvLyBJZiB0aGUgY291bnQgaXMgb2RkLCB3ZSBhcmUgaW4gdGhlIHBvbHlnb25cbiAgICByZXR1cm4gcmF5VGVzdCAlIDIgPT09IDE7XG4gIH1cblxuICByZW5kZXJlci5hZGRNb3VzZU92ZXJFdmVudChmdW5jdGlvbiAoeCwgeSkge1xuICAgIGlmIChzZWxmLnRpbWVab25lcygpLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuXG4gICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLnRpbWVab25lcygpLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgem9uZSA9IHNlbGYudGltZVpvbmVzKClbaV07XG4gICAgICB2YXIgYm91bmRpbmdCb3ggPSB6b25lLmJvdW5kaW5nQm94O1xuICAgICAgaWYgKGJvdW5kaW5nQm94ID09PSB1bmRlZmluZWQpIHJldHVybjtcblxuICAgICAgLy8gU291cmNlOiBodHRwczovL2dpdGh1Yi5jb20vZG9zeC90aW1lem9uZS1waWNrZXJcbiAgICAgIGlmICh5ID4gYm91bmRpbmdCb3gueHlNYXgueSAmJiB5IDwgYm91bmRpbmdCb3gueHlNaW4ueSAmJiB4ID4gYm91bmRpbmdCb3gueHlNaW4ueCAmJiB4IDwgYm91bmRpbmdCb3gueHlNYXgueCkge1xuICAgICAgICAvLyBNb3VzZSBpcyBpbiB0aGUgem9uZSBib3VuZHMsIHNvIG5vdyBoYXZlIHRvIGNoZWNrIGlmIGl0IGlzIGluIG9uZSBvZiB0aGlzIHpvbmUncyByZWdpb25zXG4gICAgICAgIHZhciByZWdpb25zID0gc2VsZi50aW1lWm9uZVJlZ2lvbnMoKVt6b25lLm5hbWVdO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gcmVnaW9ucykge1xuICAgICAgICAgIGlmICghcmVnaW9ucy5oYXNPd25Qcm9wZXJ0eShrZXkpKSBjb250aW51ZTtcbiAgICAgICAgICBpZiAocmF5Q2FzdFRlc3QocmVnaW9uc1trZXldLmNvb3JkcywgeCwgeSkpIHtcbiAgICAgICAgICAgIF9ob3ZlclRpbWVab25lS2V5ID0gem9uZS5uYW1lO1xuICAgICAgICAgICAgX2hvdmVyUmVnaW9uS2V5ID0ga2V5O1xuICAgICAgICAgICAgX21vdXNlWCA9IHg7XG4gICAgICAgICAgICBfbW91c2VZID0geTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHNlbGYuY2VudGVyTGF0KCksIHNlbGYuY2VudGVyTG5nKCkpO1xuXG4gIHJlbmRlcmVyLmFkZE1vdXNlU2Nyb2xsRXZlbnQoZnVuY3Rpb24gKHpvb20pIHtcbiAgICBpZiAoem9vbSA+IDEpIHtcbiAgICAgIHNlbGYuem9vbShzZWxmLnpvb20oKSArIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmLnpvb20oc2VsZi56b29tKCkgLSAxKTtcbiAgICB9XG5cbiAgICBpZiAoc2VsZi56b29tKCkgPCAxKSB7XG4gICAgICAvLyBDYW4ndCB6b29tIGFueSBsb3dlclxuICAgICAgc2VsZi56b29tKDEpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfSk7XG59OyIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gUmVuZGVyZXIoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB2YXIgd2lkdGggPSAxMjAwLFxuICAgICAgaGVpZ2h0ID0gNzAwO1xuICB2YXIgY2FudmFzID0gJCgnI3RoZUNhbnZhcycpWzBdO1xuICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICB2YXIgaW1hZ2VCYWNrZ3JvdW5kO1xuICB2YXIgbWF0cml4ID0gWzEsIDAsIDAsIDEsIDAsIDBdO1xuICB2YXIgdHJhbnNmb3JtQXBwbGllZCA9IGZhbHNlO1xuXG4gIC8vIFRPRE8gTWFrZSBjb2xvciBhIHByb3BlcnR5IGhlcmUgKG9ic2VydmFibGU/KVxuICAvLyBUaGVuIEkgY2FuIGp1c3Qgc2V0IHRoZSBjb2xvciBiZWZvcmUgY2FsbGluZyBhIGRyYXdpbmcgZnVuY3Rpb25cblxuICBzZWxmLnJlbmRlckZ1bmN0aW9uID0ga28ub2JzZXJ2YWJsZSgpO1xuICBzZWxmLnN0b3BSZW5kZXJpbmcgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcblxuICBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgaWYgKHNlbGYuc3RvcFJlbmRlcmluZygpKSByZXR1cm47XG4gICAgdHJ5IHtcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShyZW5kZXIpO1xuXG4gICAgICAvLyBDbGVhciB0aGUgY2FudmFzIGVhY2ggZnJhbWVcbiAgICAgIGNsZWFyKCk7XG4gICAgICBkcmF3SW1hZ2VCYWNrZ3JvdW5kKCk7XG5cbiAgICAgIGlmIChzZWxmLnJlbmRlckZ1bmN0aW9uKCkpIHNlbGYucmVuZGVyRnVuY3Rpb24oKSgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIFN3YWxsb3dpbmcgZXhlcHRpb25zIHRpbGwgSSBmaWd1cmUgYSBiZXR0ZXIgd2F5IHRvIHJlcG9ydCB0aGVtXG4gICAgfVxuICB9XG4gIHJlbmRlcigpO1xuXG4gIC8vIExvYWRzIGEgdXJsIGludG8gYW4gaW1hZ2UgdGhlbiBkcmF3cyB0aGF0IGltYWdlIHRvIHRoZSBjYW52YXNcbiAgc2VsZi5sb2FkSW1hZ2UgPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgaWYgKGltYWdlQmFja2dyb3VuZCA9PT0gdW5kZWZpbmVkKSBpbWFnZUJhY2tncm91bmQgPSBuZXcgSW1hZ2UoKTtcbiAgICBpbWFnZUJhY2tncm91bmQub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gTm9ybWFsbHksIDAsMCB3b3VsZCBiZSB0aGUgdG9wIGxlZnQgb2YgdGhlIGNhbnZhcy5cbiAgICAgIC8vIEkgbmVlZCB0byB0cmFuc2xhdGUgdGhlIGNhbnZhcyBhbmQgdGhlIG1hcCBpbWFnZSBzbyB0aGF0IHRoZSBjZW50ZXIgb2YgdGhlIGNhbnZhcyBpcyAwLDBcbiAgICAgIHZhciBjZW50ZXJYID0gY2FudmFzLndpZHRoIC8gMjtcbiAgICAgIHZhciBjZW50ZXJZID0gY2FudmFzLmhlaWdodCAvIDI7XG4gICAgICBpZiAoIXRyYW5zZm9ybUFwcGxpZWQpIHtcbiAgICAgICAgLy8gU2F2ZSB0aGUgdHJhbnNsYXRlIGluIHRoZSBtYXRyaXhcbiAgICAgICAgbWF0cml4WzRdICs9IG1hdHJpeFswXSAqIGNlbnRlclggKyBtYXRyaXhbMl0gKiBjZW50ZXJZO1xuICAgICAgICBtYXRyaXhbNV0gKz0gbWF0cml4WzFdICogY2VudGVyWCArIG1hdHJpeFszXSAqIGNlbnRlclk7XG4gICAgICAgIGNvbnRleHQudHJhbnNsYXRlKGNlbnRlclgsIGNlbnRlclkpO1xuICAgICAgICB0cmFuc2Zvcm1BcHBsaWVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQuZHJhd0ltYWdlKGltYWdlQmFja2dyb3VuZCwgY2VudGVyWCAqIC0xLCBjZW50ZXJZICogLTEsIHdpZHRoLCBoZWlnaHQpO1xuICAgIH07XG4gICAgaW1hZ2VCYWNrZ3JvdW5kLnNyYyA9IHVybDtcbiAgfTtcblxuICBmdW5jdGlvbiBkcmF3SW1hZ2VCYWNrZ3JvdW5kKCkge1xuICAgIGlmICghaW1hZ2VCYWNrZ3JvdW5kKSByZXR1cm47XG4gICAgdmFyIGNlbnRlclggPSBjYW52YXMud2lkdGggLyAyO1xuICAgIHZhciBjZW50ZXJZID0gY2FudmFzLmhlaWdodCAvIDI7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBjb250ZXh0LmRyYXdJbWFnZShpbWFnZUJhY2tncm91bmQsIGNlbnRlclggKiAtMSwgY2VudGVyWSAqIC0xLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICB9XG5cbiAgc2VsZi5lbGxpcHNlID0gZnVuY3Rpb24gKHgsIHksIHdpZHRoLCBoZWlnaHQsIGNvbG9yKSB7XG4gICAgY29sb3IgPSBjb252ZXJ0SGV4KGNvbG9yLCAxMDApO1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgLy8gRWxsaXBzZTogdm9pZCBjb250ZXh0LmVsbGlwc2UoeCwgeSwgcmFkaXVzWCwgcmFkaXVzWSwgcm90YXRpb24sIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpY2xvY2t3aXNlKTtcbiAgICBjb250ZXh0LmVsbGlwc2UoeCwgeSwgd2lkdGggLyAyLCBoZWlnaHQgLyAyLCAwLCAyICogTWF0aC5QSSwgZmFsc2UpO1xuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gY29sb3I7XG4gICAgY29udGV4dC5maWxsKCk7XG4gIH07XG5cbiAgc2VsZi5wb2x5Z29uID0gZnVuY3Rpb24gKHBvaW50cywgY29sb3IsIGFscGhhKSB7XG4gICAgdmFyIHBvbHlnb25Qb2ludHMgPSBwb2ludHMuc2xpY2UoMCk7IC8vIE5lZWQgYSBjb3B5IG9mIHRoZSBwb2ludHMgaGVyZVxuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgY29sb3IgPSBjb252ZXJ0SGV4KGNvbG9yLCBhbHBoYSk7XG4gICAgY29udGV4dC5maWxsU3R5bGUgPSBjb2xvcjtcblxuICAgIHZhciBmaXJzdFBvaW50ID0gcG9seWdvblBvaW50c1swXTtcbiAgICB2YXIgc2VwYXJhdGVQb2ludHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvbHlnb25Qb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwb2ludCA9IHBvbHlnb25Qb2ludHNbaV07XG4gICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICBjb250ZXh0Lm1vdmVUbyhwb2ludC54LCBwb2ludC55KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwb2ludC54ID09PSBmaXJzdFBvaW50LnggJiYgcG9pbnQueSA9PT0gZmlyc3RQb2ludC55ICYmIGkgPCBwb2x5Z29uUG9pbnRzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAvLyBOZWVkIHRvIGNyZWF0ZSBhIHNlcGFyYXRlIHBvbHlnb24gZm9yIHRoZXNlIHBvaW50c1xuICAgICAgICAgIHNlcGFyYXRlUG9pbnRzID0gcG9seWdvblBvaW50cy5zcGxpY2UoaSArIDEsIHBvbHlnb25Qb2ludHMubGVuZ3RoIC0gaSk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5saW5lVG8ocG9pbnQueCwgcG9pbnQueSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29udGV4dC5maWxsKCk7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcblxuICAgIGlmIChzZXBhcmF0ZVBvaW50cy5sZW5ndGggPiAwKSBzZWxmLnBvbHlnb24oc2VwYXJhdGVQb2ludHMsIGNvbG9yKTtcbiAgfTtcblxuICBzZWxmLnRleHQgPSBmdW5jdGlvbiAoeCwgeSwgdGV4dCwgY29sb3IsIGNlbnRlclRleHQpIHtcbiAgICBjb250ZXh0LmZvbnQgPSAnYm9sZCAxNnB4IFNlZ29lIFVJJztcbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgIGlmIChjZW50ZXJUZXh0KSB7XG4gICAgICB2YXIgbWV0cmljcyA9IGNvbnRleHQubWVhc3VyZVRleHQodGV4dCk7XG4gICAgICB4IC09IG1ldHJpY3Mud2lkdGggLyAyO1xuICAgIH1cbiAgICBjb250ZXh0LmZpbGxUZXh0KHRleHQsIHgsIHkpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIGNvbnRleHQuY2xlYXJSZWN0KDAgLSBjYW52YXMud2lkdGggLyAyLCAwIC0gY2FudmFzLmhlaWdodCAvIDIsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gIH1cblxuICBzZWxmLndpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB3aWR0aDtcbiAgfTtcblxuICBzZWxmLmhlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gaGVpZ2h0O1xuICB9O1xuXG4gIHZhciBfbW91c2VPdmVyRXZlbnQsIF9jZW50ZXJMYXQsIF9jZW50ZXJMbmc7XG4gIHNlbGYuYWRkTW91c2VPdmVyRXZlbnQgPSBmdW5jdGlvbiAobW91c2VPdmVyRXZlbnQsIGNlbnRlckxhdCwgY2VudGVyTG5nKSB7XG4gICAgX21vdXNlT3ZlckV2ZW50ID0gbW91c2VPdmVyRXZlbnQ7XG4gICAgX2NlbnRlckxhdCA9IGNlbnRlckxhdDtcbiAgICBfY2VudGVyTG5nID0gY2VudGVyTG5nO1xuICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHZhciByZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAvLyBUaGUgY2FudmFzIHVzZXMgdGhlIGNlbnRlciBhcyBpdHMgKDAsIDApIHBvaW50XG4gICAgICB2YXIgY2VudGVyWCA9IGNhbnZhcy53aWR0aCAvIDI7XG4gICAgICB2YXIgY2VudGVyWSA9IGNhbnZhcy5oZWlnaHQgLyAyO1xuXG4gICAgICB2YXIgeCA9IGV2ZW50LmNsaWVudFggLSByZWN0LmxlZnQgLSBjZW50ZXJYO1xuICAgICAgdmFyIHkgPSBldmVudC5jbGllbnRZIC0gcmVjdC50b3AgLSBjZW50ZXJZO1xuICAgICAgX21vdXNlT3ZlckV2ZW50KHgsIHkpO1xuICAgIH0sIGZhbHNlKTtcbiAgfTtcblxuICB2YXIgX3Njcm9sbENhbGxiYWNrO1xuICBzZWxmLmFkZE1vdXNlU2Nyb2xsRXZlbnQgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICBfc2Nyb2xsQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V3aGVlbCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB3aGVlbCA9IGV2ZW50LndoZWVsRGVsdGEgLyAxMjA7XG4gICAgICBfc2Nyb2xsQ2FsbGJhY2soMSArIHdoZWVsIC8gMik7XG4gICAgfSwgZmFsc2UpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGNvbnZlcnRIZXgoaGV4LCBhbHBoYSkge1xuICAgIHZhciByID0gcGFyc2VJbnQoaGV4LnNsaWNlKDEsIDMpLCAxNik7XG4gICAgdmFyIGcgPSBwYXJzZUludChoZXguc2xpY2UoMywgNSksIDE2KTtcbiAgICB2YXIgYiA9IHBhcnNlSW50KGhleC5zbGljZSg1LCA3KSwgMTYpO1xuICAgIHZhciBhID0gcGFyc2VJbnQoYWxwaGEsIDE2KSAvIDI1NTtcbiAgICByZXR1cm4gJ3JnYmEoJyArIHIgKyAnLCAnICsgZyArICcsICcgKyBiICsgJywgJyArIGEgKyAnKSc7XG4gIH1cbn0iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIFRpbWVab25lU2VydmljZShtYXBXaWR0aCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdmFyIG1lcmNVbml0cyA9IG1hcFdpZHRoIC8gNDtcblxuICAvLyBUaGlzIGlzIGFuIG9ic2VydmFibGUgdGhhdCB0aGUgY2FsbGVyIHBhc3NlcyBpblxuICAvLyBJdCB3aWxsIGJlIHVwZGF0ZWQgYXMgdGhlIHNlcnZpY2UgZmluaXNoZXMgZWFjaCBvZiBpdCdzIHJlcXVlc3RzXG4gIHZhciBfdGltZVpvbmVzT2JzZXJ2YWJsZTtcbiAgdmFyIF90aW1lWm9uZVJlZ2lvbnNPYnNlcnZhYmxlO1xuICB2YXIgX2NlbnRlckxhdDtcbiAgdmFyIF9jZW50ZXJMbmc7XG4gIHZhciBfem9vbTtcbiAgdmFyIF9lcnJvckNhbGxiYWNrO1xuXG4gIC8vIFRoZXNlIG5lZWQgdG8gYmUgb2JzZXJ2YWJsZXMgZnJvbSBDb2xvclpvbmVzXG4gIHNlbGYuc2V0dXAgPSBmdW5jdGlvbiAoY2VudGVyTGF0LCBjZW50ZXJMbmcsIHpvb20pIHtcbiAgICBfY2VudGVyTGF0ID0gY2VudGVyTGF0O1xuICAgIF9jZW50ZXJMbmcgPSBjZW50ZXJMbmc7XG4gICAgX3pvb20gPSB6b29tO1xuICB9O1xuXG4gIHNlbGYubG9hZFRpbWVab25lcyA9IGZ1bmN0aW9uIChlcnJvckNhbGxiYWNrLCB0aW1lWm9uZXNPYnNlcnZhYmxlLCB0aW1lWm9uZVJlZ2lvbnNPYnNlcnZhYmxlKSB7XG4gICAgX2Vycm9yQ2FsbGJhY2sgPSBlcnJvckNhbGxiYWNrO1xuICAgIGlmIChfY2VudGVyTGF0ID09PSB1bmRlZmluZWQgfHwgX2NlbnRlckxuZyA9PT0gdW5kZWZpbmVkIHx8IF96b29tID09PSB1bmRlZmluZWQpIHtcbiAgICAgIF9lcnJvckNhbGxiYWNrKCdZb3UgbmVlZCB0byBjYWxsIFRpbWVab25lU2VydmljZS5zZXRDZW50ZXJDb29yZGluYXRlcyhjZW50ZXJMYXQsIGNlbnRlckxuZywgem9vbSkgZmlyc3QhJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIF90aW1lWm9uZXNPYnNlcnZhYmxlID0gdGltZVpvbmVzT2JzZXJ2YWJsZTtcbiAgICBfdGltZVpvbmVSZWdpb25zT2JzZXJ2YWJsZSA9IHRpbWVab25lUmVnaW9uc09ic2VydmFibGU7XG5cbiAgICAvLyBMb2FkIHRoZSB0aW1lIHpvbmUgcmVnaW9uc1xuICAgIGZldGNoKCcvYXBpL2NvbG9yLXpvbmVzL2hvdmVyLXJlZ2lvbnMnKS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBfZXJyb3JDYWxsYmFjaygnU29tZXRoaW5nIHdlbnQgd3JvbmcgdHJ5aW5nIHRvIGxvYWQgdGhlIHRpbWUgem9uZSByZWdpb25zLi4uJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJlc3BvbnNlLmpzb24oKS50aGVuKGZ1bmN0aW9uIChqc29uKSB7XG4gICAgICAgIHZhciBob3ZlclJlZ2lvbnMgPSBKU09OLnBhcnNlKGpzb24pO1xuXG4gICAgICAgIGZ1bmN0aW9uIGdldFRpbWVab25lKGhvdmVyUmVnaW9uKSB7XG4gICAgICAgICAgLy8gRWFjaCBob3ZlciByZWdpb24gY29udGFpbnMgYSBob3ZlciByZWdpb24gYXJyYXkgb2YgcG9pbnRzXG4gICAgICAgICAgdmFyIGNvb3JkcyA9IFtdO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG92ZXJSZWdpb24uaG92ZXJSZWdpb24ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIC8vIEV2ZXJ5IHR3byBwb2ludHMgaW4gdGhlIGhvdmVyIHJlZ2lvbiBhcmUgdGhlIGxhdCBhbmQgbG5nXG4gICAgICAgICAgICB2YXIgcmVnaW9uID0gaG92ZXJSZWdpb24uaG92ZXJSZWdpb25baV07XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJlZ2lvbi5wb2ludHMubGVuZ3RoOyBqICs9IDIpIHtcbiAgICAgICAgICAgICAgdmFyIHBvaW50UGFpciA9IHJlZ2lvbi5wb2ludHMuc2xpY2UoaiwgaiArIDIpO1xuICAgICAgICAgICAgICB2YXIgeHkgPSBnZXRYWShwb2ludFBhaXJbMF0sIHBvaW50UGFpclsxXSk7XG4gICAgICAgICAgICAgIGNvb3Jkcy5wdXNoKHh5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBUaW1lWm9uZShob3ZlclJlZ2lvbi5uYW1lLCBjb29yZHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob3ZlclJlZ2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgdGltZVpvbmUgPSBnZXRUaW1lWm9uZShob3ZlclJlZ2lvbnNbaV0pO1xuICAgICAgICAgIGxvYWRab25lUG9seWdvbnModGltZVpvbmUpO1xuICAgICAgICAgIF90aW1lWm9uZXNPYnNlcnZhYmxlKCkucHVzaCh0aW1lWm9uZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBbGwgdGltZSB6b25lcyBhcmUgbG9hZGVkLCBzbyB3ZSBjYW4gbm93IGxvYWQgdGhlIGJvdW5kaW5nIGJveGVzXG4gICAgICAgIGxvYWRCb3VuZGluZ0JveGVzKCk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHNlbGYucmVsb2FkQ29vcmRpbmF0ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF90aW1lWm9uZXNPYnNlcnZhYmxlKCkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNvb3JkcyA9IF90aW1lWm9uZXNPYnNlcnZhYmxlKClbaV0uY29vcmRzO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvb3Jkcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGNvb3Jkc1tqXSA9IGdldFhZKGNvb3Jkc1tqXS54LCBjb29yZHNbal0ueSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gTG9hZCB0aGUgYm91bmRpbmcgYm94ZXNcbiAgICBmdW5jdGlvbiBsb2FkQm91bmRpbmdCb3hlcygpIHtcbiAgICAgIGZldGNoKCcvYXBpL2NvbG9yLXpvbmVzL21hcC1ib3VuZHMnKS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgLy8gVE9ETyBIYW5kbGUgZXJyb3IgaGVyZVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXNwb25zZS5qc29uKCkudGhlbihmdW5jdGlvbiAoanNvbikge1xuICAgICAgICAgIHZhciBib3VuZGluZ0JveGVzID0gSlNPTi5wYXJzZShqc29uKTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvdW5kaW5nQm94ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBib3ggPSBib3VuZGluZ0JveGVzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBfdGltZVpvbmVzT2JzZXJ2YWJsZSgpLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgIGlmIChfdGltZVpvbmVzT2JzZXJ2YWJsZSgpW2pdLm1hdGNoZXNJZChib3gubmFtZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgeHlNaW4gPSBnZXRYWShib3guYm91bmRpbmdCb3gueW1pbiwgYm94LmJvdW5kaW5nQm94LnhtaW4pO1xuICAgICAgICAgICAgICAgIHZhciB4eU1heCA9IGdldFhZKGJveC5ib3VuZGluZ0JveC55bWF4LCBib3guYm91bmRpbmdCb3gueG1heCk7XG4gICAgICAgICAgICAgICAgX3RpbWVab25lc09ic2VydmFibGUoKVtqXS5ib3VuZGluZ0JveCA9IHtcbiAgICAgICAgICAgICAgICAgIHh5TWluOiB4eU1pbixcbiAgICAgICAgICAgICAgICAgIHh5TWF4OiB4eU1heFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gTG9hZCB0aGUgcG9seWdvbnMgZm9yIGEgdGltZSB6b25lXG4gICAgZnVuY3Rpb24gbG9hZFpvbmVQb2x5Z29ucyh0aW1lWm9uZSkge1xuICAgICAgdmFyIHpvbmVOYW1lID0gdGltZVpvbmUubmFtZS5yZXBsYWNlKC9cXC98Xy9nLCAnLScpO1xuICAgICAgZmV0Y2goJy9hcGkvY29sb3Item9uZXMvcG9seWdvbnMvJyArIHpvbmVOYW1lKS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgX2Vycm9yQ2FsbGJhY2soJ1NvbWV0aGluZyB3ZW50IHdyb25nIHRyeWluZyB0byBsb2FkIHRoZSB0aW1lIHpvbmUgcG9seWdvbnMgZm9yICcgKyB6b25lTmFtZSArICcuLi4nKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVzcG9uc2UuanNvbigpLnRoZW4oZnVuY3Rpb24gKGpzb24pIHtcbiAgICAgICAgICB2YXIgZGF0YSA9IEpTT04ucGFyc2UoanNvbik7XG4gICAgICAgICAgdmFyIHBvbHlnb25zID0ge307XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEucG9seWdvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIC8vIExvb3AgdGhyb3VnaCBhbGwgdGhlIHBvaW50cyBpbiB0aGUgcG9seWdvblxuICAgICAgICAgICAgLy8gRXZlcnkgMiBwb2ludHMgYXJlIGEgbGF0ICYgbG5nIHBhaXJcbiAgICAgICAgICAgIHZhciBwb2x5Z29uRGF0YSA9IGRhdGEucG9seWdvbnNbaV07XG4gICAgICAgICAgICB2YXIgY29vcmRzID0gW107XG5cbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcG9seWdvbkRhdGEucG9pbnRzLmxlbmd0aDsgaiArPSAyKSB7XG4gICAgICAgICAgICAgIHZhciBjb29yZCA9IHBvbHlnb25EYXRhLnBvaW50cy5zbGljZShqLCBqICsgMik7XG4gICAgICAgICAgICAgIHZhciB4eSA9IGdldFhZKGNvb3JkWzBdLCBjb29yZFsxXSk7XG4gICAgICAgICAgICAgIGNvb3Jkcy5wdXNoKHh5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHBvbHlnb24gaGFzIGFscmVhZHkgYmVlbiBjcmVhdGVkXG4gICAgICAgICAgICB2YXIgcG9seWdvbiA9IHBvbHlnb25zW3BvbHlnb25EYXRhLm5hbWVdO1xuICAgICAgICAgICAgaWYgKHBvbHlnb24pIHtcbiAgICAgICAgICAgICAgcG9seWdvbi5jb29yZHMgPSBwb2x5Z29uLmNvb3Jkcy5jb25jYXQoY29vcmRzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBvbHlnb24gPSBuZXcgUG9seWdvbihwb2x5Z29uRGF0YS5uYW1lLCBjb29yZHMsIGdldFhZKHBvbHlnb25EYXRhLmNlbnRyb2lkWzFdLCBwb2x5Z29uRGF0YS5jZW50cm9pZFswXSkpO1xuICAgICAgICAgICAgICBwb2x5Z29uc1twb2x5Z29uRGF0YS5uYW1lXSA9IHBvbHlnb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQ2hlY2sgdG8gZWFjaCBwb2x5Z29uIHRvIGZpbmQgdGhlIGxhcmdlc3QgYnkgc2VlaW5nIGlmIGl0IGhhcyB0aGUgbW9zdCBlZGdlc1xuICAgICAgICAgIC8vIFVzZSB0aGUgbGFyZ2VzdCBwb2x5Z29uJ3MgY2VudHJvaWQgYXMgdGhlIHRpbWV6b25lIGNlbnRyb2lkXG4gICAgICAgICAgdmFyIGNlbnRyb2lkTmFtZSxcbiAgICAgICAgICAgICAgbWF4UG9pbnRzID0gMDtcbiAgICAgICAgICAkLmVhY2gocG9seWdvbnMsIGZ1bmN0aW9uIChpbmRleCwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5jb29yZHMubGVuZ3RoID4gbWF4UG9pbnRzKSB7XG4gICAgICAgICAgICAgIG1heFBvaW50cyA9IHZhbHVlLmNvb3Jkcy5sZW5ndGg7XG4gICAgICAgICAgICAgIGNlbnRyb2lkTmFtZSA9IHZhbHVlLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoIV90aW1lWm9uZVJlZ2lvbnNPYnNlcnZhYmxlKClbdGltZVpvbmUubmFtZV0pIHtcbiAgICAgICAgICAgIF90aW1lWm9uZVJlZ2lvbnNPYnNlcnZhYmxlKClbdGltZVpvbmUubmFtZV0gPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgX3RpbWVab25lUmVnaW9uc09ic2VydmFibGUoKVt0aW1lWm9uZS5uYW1lXSA9IHBvbHlnb25zO1xuICAgICAgICAgIHRpbWVab25lLmNlbnRyb2lkUG9seWdvbiA9IHBvbHlnb25zW2NlbnRyb2lkTmFtZV07XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIGdldFhZKGxhdCwgbG5nKSB7XG4gICAgdmFyIGNlbnRlclggPSBtZXJjWChfY2VudGVyTG5nKCkpO1xuICAgIHZhciBjZW50ZXJZID0gbWVyY1koX2NlbnRlckxhdCgpKTtcbiAgICB2YXIgeCA9IG1lcmNYKGxuZykgLSBjZW50ZXJYO1xuICAgIHZhciB5ID0gbWVyY1kobGF0KSAtIGNlbnRlclk7XG4gICAgcmV0dXJuIHsgeDogeCwgeTogeSB9O1xuICB9XG5cbiAgZnVuY3Rpb24gbWVyY1gobG5nKSB7XG4gICAgbG5nID0gdG9SYWRpYW5zKGxuZyk7XG4gICAgdmFyIGEgPSBtZXJjVW5pdHMgLyBNYXRoLlBJICogTWF0aC5wb3coMiwgX3pvb20oKSk7XG4gICAgdmFyIGIgPSBsbmcgKyBNYXRoLlBJO1xuICAgIHJldHVybiBhICogYjtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmNZKGxhdCkge1xuICAgIGxhdCA9IHRvUmFkaWFucyhsYXQpO1xuICAgIHZhciBhID0gbWVyY1VuaXRzIC8gTWF0aC5QSSAqIE1hdGgucG93KDIsIF96b29tKCkpO1xuICAgIHZhciBiID0gTWF0aC50YW4oTWF0aC5QSSAvIDQgKyBsYXQgLyAyKTtcbiAgICB2YXIgYyA9IE1hdGguUEkgLSBNYXRoLmxvZyhiKTtcbiAgICByZXR1cm4gYSAqIGM7XG4gIH1cblxuICBmdW5jdGlvbiB0b1JhZGlhbnMoZGVncmVlcykge1xuICAgIHJldHVybiBkZWdyZWVzICogKE1hdGguUEkgLyAxODApO1xuICB9XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBUb29sdGlwU2VydmljZSh0b29sdGlwcykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdmFyIHN0b3JhZ2VLZXkgPSAndG9vbHRpcHNTaG93bic7XG5cbiAgc2VsZi5sb2FkVG9vbGlwcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdG9vbHRpcHNTaG93biA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKHN0b3JhZ2VLZXkpO1xuICAgIGlmICh0b29sdGlwcy5sZW5ndGggPT09IDAgfHwgdG9vbHRpcHNTaG93bikgcmV0dXJuO1xuICAgIHNob3dUb29sdGlwKDApO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHNob3dUb29sdGlwKGluZGV4KSB7XG4gICAgaWYgKGluZGV4ID09PSB0b29sdGlwcy5sZW5ndGgpIHJldHVybjtcbiAgICB0cnkge1xuICAgICAgdG9vbHRpcHNbaW5kZXhdLmlkLnRvb2x0aXAoJ3Nob3cnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuXG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0b29sdGlwc1tpbmRleF0uaWQudG9vbHRpcCgnZGlzcG9zZScpO1xuICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgIC8vIEluY3JlbWVudCB0aGUgaW5kZXggdG8gdHJ5IHRvIGdldCB0aGUgbmV4dCB0b29sdGlwXG4gICAgICBpbmRleCsrO1xuICAgICAgaWYgKCF0b29sdGlwc1tpbmRleF0pIHtcbiAgICAgICAgLy8gRG9uJ3Qgc2hvdyB0aGUgdG9vbHRpcHMgYWdhaW5cbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oc3RvcmFnZUtleSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBzaG93VG9vbHRpcChpbmRleCk7XG4gICAgfSwgdG9vbHRpcHNbaW5kZXhdLnRpbWVvdXQgKiAxMDAwKTtcbiAgfVxufSIsIid1c2Ugc3RyaWN0JztcblxuLyoqXHJcbiAqIENyZWF0ZWQgYnkgRWR3YXJkIG9uIDEwLzcvMjAxNC5cclxuICovXG5hbmd1bGFyLm1vZHVsZSgnbWNuZWR3YXJkJykuY29udHJvbGxlcignSUlDdHJsJywgWyckc2NvcGUnLCAnbW9kYWxTZXJ2aWNlJywgZnVuY3Rpb24gSUlDdHJsKCRzY29wZSwgbW9kYWxTZXJ2aWNlKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHQkc2NvcGUuaWlJbmZvID0ge307XG5cdCRzY29wZS5pc0Zvcm1TdWJtaXR0ZWQgPSBmYWxzZTtcblxuXHRmdW5jdGlvbiBzaG93QXBwRXJyb3IoZXJyb3JNZXNzYWdlKSB7XG5cdFx0JHNjb3BlLnNob3dBcHBFcnJvciA9IHRydWU7XG5cdFx0JHNjb3BlLmFwcEVycm9yID0gZXJyb3I7XG5cdH1cblx0ZnVuY3Rpb24gc2hvd0xpYkVycm9yKGVycm9yTWVzc2FnZSkge1xuXHRcdCRzY29wZS5zaG93TGliRXJyb3IgPSB0cnVlO1xuXHRcdCRzY29wZS5saWJFcnJvciA9IGVycm9yO1xuXHR9XG5cdGZ1bmN0aW9uIGNsZWFyQXBwRXJyb3IoZXJyb3JNZXNzYWdlKSB7XG5cdFx0JHNjb3BlLnNob3dBcHBFcnJvciA9IGZhbHNlO1xuXHRcdCRzY29wZS5hcHBFcnJvciA9ICcnO1xuXHR9XG5cdGZ1bmN0aW9uIGNsZWFyTGliRXJyb3IoZXJyb3JNZXNzYWdlKSB7XG5cdFx0JHNjb3BlLnNob3dMaWJFcnJvciA9IGZhbHNlO1xuXHRcdCRzY29wZS5saWJFcnJvciA9ICcnO1xuXHR9XG5cblx0JHNjb3BlLm9wZW5Eb3dubG9hZEZvckFwcCA9IGZ1bmN0aW9uICgpIHtcblx0XHRjbGVhckFwcEVycm9yKCk7XG5cdFx0bW9kYWxTZXJ2aWNlLnNob3dNb2RhbCgnZG93bmxvYWRBcHBNb2RhbCcpO1xuXHR9O1xuXHQkc2NvcGUub3BlbkRvd25sb2FkRm9yTGliID0gZnVuY3Rpb24gKCkge1xuXHRcdGNsZWFyTGliRXJyb3IoKTtcblx0XHRtb2RhbFNlcnZpY2Uuc2hvd01vZGFsKCdkb3dubG9hZExpYk1vZGFsJyk7XG5cdH07XG5cblx0JHNjb3BlLmRvd25sb2FkSUlBcHAgPSBmdW5jdGlvbiAoZm9ybSwgaWlBcHBJbmZvKSB7XG5cdFx0aWYgKCRzY29wZS5pc0FwcEZvcm1TdWJtaXR0ZWQpIHJldHVybjtcblx0XHRmb3JtLiRzZXRTdWJtaXR0ZWQoKTtcblx0XHRpZiAoZm9ybS4kaW52YWxpZCkgcmV0dXJuO1xuXHRcdCRzY29wZS5pc0FwcEZvcm1TdWJtaXR0ZWQgPSB0cnVlO1xuXHRcdGZvcm0uJHNldFByaXN0aW5lKCk7XG5cdFx0Zm9ybS4kc2V0VW50b3VjaGVkKCk7XG5cdFx0Y2xlYXJBcHBFcnJvcigpO1xuXG5cdFx0dmFyIGRvd25sb2FkVXJsID0gJy9hcGkvaWkvYXBwP3NlY3JldFJlc3BvbnNlPScgKyBpaUFwcEluZm8ucmVjYXB0Y2hhUmVzcG9uc2U7XG5cdFx0d2luZG93LmxvY2F0aW9uLmhyZWYgPSBkb3dubG9hZFVybDtcblx0fTtcblx0JHNjb3BlLmRvd25sb2FkSUlMaWIgPSBmdW5jdGlvbiAoZm9ybSwgaWlMaWJJbmZvKSB7XG5cdFx0aWYgKCRzY29wZS5pc0xpYkZvcm1TdWJtaXR0ZWQpIHJldHVybjtcblx0XHRmb3JtLiRzZXRTdWJtaXR0ZWQoKTtcblx0XHRpZiAoZm9ybS4kaW52YWxpZCkgcmV0dXJuO1xuXHRcdCRzY29wZS5pc0xpYkZvcm1TdWJtaXR0ZWQgPSB0cnVlO1xuXHRcdGZvcm0uJHNldFByaXN0aW5lKCk7XG5cdFx0Zm9ybS4kc2V0VW50b3VjaGVkKCk7XG5cdFx0Y2xlYXJMaWJFcnJvcigpO1xuXG5cdFx0dmFyIGRvd25sb2FkVXJsID0gJy9hcGkvaWkvbGliP3NlY3JldFJlc3BvbnNlPScgKyBpaUxpYkluZm8ucmVjYXB0Y2hhUmVzcG9uc2U7XG5cdFx0d2luZG93LmxvY2F0aW9uLmhyZWYgPSBkb3dubG9hZFVybDtcblx0fTtcbn1dKTsiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxyXG4gKiBDcmVhdGVkIGJ5IEVkd2FyZCBvbiAxMS84LzIwMTQuXHJcbiAqL1xuYW5ndWxhci5tb2R1bGUoJ21jbmVkd2FyZCcpLmNvbnRyb2xsZXIoJ051bWJlclByaW50ZXJDdHJsJywgWyckc2NvcGUnLCBmdW5jdGlvbiBOdW1iZXJQcmludGVyQ3RybCgkc2NvcGUpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gICRzY29wZS5yZXN1bHQgPSAnJztcblxuICAkc2NvcGUuY29udmVydFRvRW5nbGlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb252ZXJ0KGZ1bmN0aW9uIChqc29uKSB7XG4gICAgICAkc2NvcGUucmVzdWx0ID0ganNvbi5lbmdsaXNoV29yZDtcbiAgICAgICRzY29wZS4kYXBwbHkoKTtcbiAgICB9KTtcbiAgfTtcblxuICAkc2NvcGUuY29udmVydFRvUm9tYW5OdW1lcmFsID0gZnVuY3Rpb24gKCkge1xuICAgIGNvbnZlcnQoZnVuY3Rpb24gKGpzb24pIHtcbiAgICAgICRzY29wZS5yZXN1bHQgPSBqc29uLnJvbWFuTnVtZXJhbDtcbiAgICAgICRzY29wZS4kYXBwbHkoKTtcbiAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBjb252ZXJ0KGNhbGxiYWNrKSB7XG4gICAgY2xlYXJUZXh0KCk7XG4gICAgdmFyIG51bWJlciA9ICRzY29wZS5udW1iZXI7XG4gICAgaWYgKG51bWJlciA9PT0gJycpIHtcbiAgICAgICRzY29wZS5lcnJvck1lc3NhZ2UgPSAnWW91IG5lZWQgdG8gZW50ZXIgc29tZXRoaW5nISc7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBmZXRjaCgnL2FwaS9udW1iZXItcHJpbnRlcj9udW1iZXI9JyArIG51bWJlcikudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgICByZXNwb25zZS5qc29uKCkudGhlbihjYWxsYmFjayk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJlc3BvbnNlLnRleHQoKS50aGVuKGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgICRzY29wZS5lcnJvck1lc3NhZ2UgPSB0ZXh0O1xuICAgICAgICAkc2NvcGUuJGFwcGx5KCk7XG4gICAgICB9KTtcbiAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICRzY29wZS5lcnJvck1lc3NhZ2UgPSBlcnJvcjtcbiAgICAgICRzY29wZS4kYXBwbHkoKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFyVGV4dCgpIHtcbiAgICAkc2NvcGUucmVzdWx0ID0gJyc7XG4gICAgJHNjb3BlLmVycm9yTWVzc2FnZSA9ICcnO1xuICB9XG59XSk7IiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcclxuICogQ3JlYXRlZCBieSBFZHdhcmQgb24gMi8yOC8yMDE2LlxyXG4gKi9cbmFuZ3VsYXIubW9kdWxlKCdtY25lZHdhcmQnKS5kaXJlY3RpdmUoJ2RpcmVjdG9yeScsIFsnJHJvb3RTY29wZScsIGZ1bmN0aW9uICgkcm9vdFNjb3BlKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHRyZXR1cm4ge1xuXHRcdHJlc3RyaWN0OiAnQUUnLFxuXHRcdHRyYW5zY2x1ZGU6IHRydWUsXG5cdFx0c2NvcGU6IHtcblx0XHRcdG5hbWU6ICc9Jyxcblx0XHRcdGlkOiAnPScsXG5cdFx0XHRkaXJlY3RvcmllczogJz0nLFxuXHRcdFx0Y2xhc3NlczogJz0nXG5cdFx0fSxcblx0XHRsaW5rOiBmdW5jdGlvbiBsaW5rKHNjb3BlLCBlbGVtZW50LCBhdHRycykge1xuXHRcdFx0c2NvcGUuc2VsZWN0Q2xhc3MgPSBmdW5jdGlvbiAoZGlyZWN0b3J5SWQsIGNsYXNzSWQpIHtcblx0XHRcdFx0JHJvb3RTY29wZS4kYnJvYWRjYXN0KCdzZWxlY3RDbGFzcycsIHtcblx0XHRcdFx0XHRkaXJlY3RvcnlJZDogZGlyZWN0b3J5SWQsXG5cdFx0XHRcdFx0Y2xhc3NJZDogY2xhc3NJZFxuXHRcdFx0XHR9KTtcblx0XHRcdH07XG5cblx0XHRcdC8vIElmIHRoZXJlIGlzIG5vIG5hbWUsIHRoaXMgaXMgYSB0ZW1wb3JhcnkgZGlyZWN0b3J5IHVzZWQgb25seSBmb3IgdGhlIHVwbG9hZFxuXHRcdFx0c2NvcGUuaXNSZWFsRGlyZWN0b3J5ID0gc2NvcGUubmFtZSAhPT0gbnVsbCAmJiBzY29wZS5uYW1lICE9PSBcIlwiO1xuXHRcdFx0c2NvcGUuc2hvd0NvbnRlbnRzID0gZmFsc2U7XG5cdFx0fSxcblx0XHR0ZW1wbGF0ZVVybDogJ3BhcnNlci9kaXJlY3RvcnkuaHRtbCdcblx0fTtcbn1dKTsiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxyXG4gKiBDcmVhdGVkIGJ5IEVkd2FyZCBvbiAyLzI4LzIwMTYuXHJcbiAqL1xuYW5ndWxhci5tb2R1bGUoJ21jbmVkd2FyZCcpLmRpcmVjdGl2ZSgnZHJhZ0FuZERyb3AnLCBbJyRyb290U2NvcGUnLCAnJHRpbWVvdXQnLCBmdW5jdGlvbiAoJHJvb3RTY29wZSwgJHRpbWVvdXQpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdHJldHVybiB7XG5cdFx0cmVzdHJpY3Q6ICdFJyxcblx0XHRsaW5rOiBmdW5jdGlvbiBsaW5rKHNjb3BlLCBlbGVtZW50LCBhdHRycykge1xuXHRcdFx0dmFyIGRlZmF1bHREcmFnQXJlYU1lc3NhZ2UgPSAnRHJhZyBmaWxlcyBoZXJlISc7XG5cdFx0XHRzY29wZS5kcmFnQXJlYU1lc3NhZ2UgPSBkZWZhdWx0RHJhZ0FyZWFNZXNzYWdlO1xuXHRcdFx0c2NvcGUuZHJhZ292ZXJDbGFzcyA9ICcnO1xuXHRcdFx0c2NvcGUudXBsb2FkUHJvZ3Jlc3MgPSAwO1xuXG5cdFx0XHRzY29wZS5oYW5kbGVFcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlLCBlcnJvcikge1xuXHRcdFx0XHRzY29wZS5maWxlU2VsZWN0ZWQgPSBmYWxzZTtcblx0XHRcdFx0c2NvcGUuaGFzRXJyb3IgPSB0cnVlO1xuXHRcdFx0XHRzY29wZS5sb2FkKGZhbHNlKTtcblx0XHRcdFx0c2NvcGUuZHJhZ292ZXJDbGFzcyA9ICdkcmFnb3Zlci1lcnJvcic7XG5cdFx0XHRcdHNjb3BlLmRyYWdBcmVhTWVzc2FnZSA9ICcnO1xuXHRcdFx0XHRzY29wZS5kcmFnQXJlYUVycm9yID0gbWVzc2FnZTtcblx0XHRcdFx0Y29uc29sZS5sb2coZXJyb3IsIG1lc3NhZ2UpO1xuXHRcdFx0fTtcblxuXHRcdFx0dmFyIGZpcnN0VGltZSA9IHRydWU7XG5cdFx0XHR2YXIgbG9hZGluZyA9IGZhbHNlO1xuXHRcdFx0c2NvcGUubG9hZCA9IGZ1bmN0aW9uIChpc0xvYWRpbmcpIHtcblx0XHRcdFx0c2NvcGUuZHJhZ0FyZWFFcnJvciA9ICcnO1xuXHRcdFx0XHRpZiAoaXNMb2FkaW5nKSB7XG5cdFx0XHRcdFx0bG9hZGluZyA9IHRydWU7XG5cdFx0XHRcdFx0c2NvcGUudXBsb2FkUHJvZ3Jlc3MgPSAwO1xuXHRcdFx0XHRcdGNoZWNrUHJvZ3Jlc3MoKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsb2FkaW5nID0gZmFsc2U7XG5cdFx0XHRcdFx0aWYgKHNjb3BlLmhhc0Vycm9yKSByZXR1cm47XG5cdFx0XHRcdFx0c2NvcGUuZHJhZ0FyZWFNZXNzYWdlID0gJ0ZpbmlzaGVkISc7XG5cdFx0XHRcdFx0c2NvcGUuZHJhZ292ZXJDbGFzcyA9ICcnO1xuXHRcdFx0XHRcdHNjb3BlLnVwbG9hZFByb2dyZXNzID0gMTAwO1xuXHRcdFx0XHRcdCR0aW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdHNjb3BlLmRyYWdBcmVhTWVzc2FnZSA9IGRlZmF1bHREcmFnQXJlYU1lc3NhZ2U7XG5cdFx0XHRcdFx0XHRzY29wZS51cGxvYWRQcm9ncmVzcyA9IDA7XG5cdFx0XHRcdFx0fSwgMzAwMCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRmdW5jdGlvbiBjaGVja1Byb2dyZXNzKCkge1xuXHRcdFx0XHQvLyAkdGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0Ly8gXHRwYXJzZXJTZXJ2aWNlLmdldFVwbG9hZFByb2dyZXNzKHNjb3BlLnNlY3JldFJlc3BvbnNlLCBzY29wZS50b2tlbikudGhlbigocmVzcG9uc2UpID0+IHtcblx0XHRcdFx0Ly8gICAgIGlmICghcmVzcG9uc2Uub2spIHJldHVybjtcblxuXHRcdFx0XHQvLyAgICAgcmVzcG9uc2UudGV4dCgpLnRoZW4oKHRleHQpID0+IHtcblx0XHRcdFx0Ly8gICAgICAgc2NvcGUudXBsb2FkUHJvZ3Jlc3MgPSB0ZXh0O1xuXHRcdFx0XHQvLyAgICAgICBpZiAobG9hZGluZykge1xuXHRcdFx0XHQvLyAgICAgICAgIGNoZWNrUHJvZ3Jlc3MoKTtcblx0XHRcdFx0Ly8gICAgICAgfVxuXHRcdFx0XHQvLyAgICAgfSk7XG5cdFx0XHRcdC8vIFx0fSk7XG5cdFx0XHRcdC8vIH0sIDMwMCk7XG5cdFx0XHR9XG5cblx0XHRcdGVsZW1lbnQuYmluZCgnZHJhZ2VudGVyJywgZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRlLm9yaWdpbmFsRXZlbnQuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3QgPSAnY29weSc7XG5cdFx0XHRcdHNjb3BlLmRyYWdvdmVyQ2xhc3MgPSAnZHJhZ292ZXInO1xuXHRcdFx0XHRzY29wZS5kcmFnQXJlYU1lc3NhZ2UgPSAnRHJvcCBmaWxlcyEnO1xuXHRcdFx0XHRzY29wZS5kcmFnQXJlYUVycm9yID0gJyc7XG5cdFx0XHRcdHNjb3BlLiRhcHBseSgpO1xuXHRcdFx0fSk7XG5cdFx0XHRlbGVtZW50LmJpbmQoJ2RyYWdsZWF2ZScsIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0c2NvcGUuZHJhZ292ZXJDbGFzcyA9ICcnO1xuXHRcdFx0XHRzY29wZS5kcmFnQXJlYU1lc3NhZ2UgPSAnRHJhZyBmaWxlcyBoZXJlISc7XG5cdFx0XHRcdHNjb3BlLmRyYWdBcmVhRXJyb3IgPSAnJztcblx0XHRcdFx0c2NvcGUuJGFwcGx5KCk7XG5cdFx0XHR9KTtcblx0XHRcdGVsZW1lbnQuYmluZCgnZHJhZ292ZXInLCBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdGUub3JpZ2luYWxFdmVudC5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9ICdjb3B5Jztcblx0XHRcdFx0c2NvcGUuZHJhZ292ZXJDbGFzcyA9ICdkcmFnb3Zlcic7XG5cdFx0XHRcdHNjb3BlLmRyYWdBcmVhTWVzc2FnZSA9ICdEcm9wIGZpbGVzISc7XG5cdFx0XHRcdHNjb3BlLmRyYWdBcmVhRXJyb3IgPSAnJztcblx0XHRcdFx0c2NvcGUuJGFwcGx5KCk7XG5cdFx0XHR9KTtcblx0XHRcdGVsZW1lbnQuYmluZCgnZHJhZ2V2ZW50JywgZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0fSk7XG5cdFx0XHRlbGVtZW50LmJpbmQoJ2Ryb3AnLCBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHRcdFx0dmFyIGZpbGVJZCA9IDE7IC8vIFVuaXF1ZSBpZCBmb3IgaWRlbnRpZnlpbmcgdGhlIGZpbGUgaW4gdGhlIHNlcnZlciBjYWNoZVxuXHRcdFx0XHR2YXIgb25FcnJvciA9IGZ1bmN0aW9uIG9uRXJyb3IoZXJyb3IpIHtcblx0XHRcdFx0XHRjb25zb2xlLmxvZyhlcnJvcik7XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0ZnVuY3Rpb24gaGFuZGxlRGlyZWN0b3J5KGl0ZW0sIGRpcmVjdG9yeSwgdG9wRGlyZWN0b3J5KSB7XG5cdFx0XHRcdFx0dmFyIHJlYWRlciA9IGl0ZW0uY3JlYXRlUmVhZGVyKCk7XG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG5cdFx0XHRcdFx0XHR2YXIgaXRlcmF0aW9uQXR0ZW1wdHMgPSBbXTtcblx0XHRcdFx0XHRcdChmdW5jdGlvbiByZWFkRGlyZWN0b3J5KGRpcmVjdG9yeSwgdG9wRGlyZWN0b3J5KSB7XG5cdFx0XHRcdFx0XHRcdHJlYWRlci5yZWFkRW50cmllcyhmdW5jdGlvbiAoZW50cmllcykge1xuXHRcdFx0XHRcdFx0XHRcdGlmICghZW50cmllcy5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFByb21pc2UuYWxsKGl0ZXJhdGlvbkF0dGVtcHRzKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRXZlcnl0aGluZyBzaG91bGQgYmUgZG9uZSBub3chXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUodG9wRGlyZWN0b3J5KTtcblx0XHRcdFx0XHRcdFx0XHRcdH0sIG9uRXJyb3IpO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpdGVyYXRpb25BdHRlbXB0cy5wdXNoKFByb21pc2UuYWxsKGVudHJpZXMubWFwKGZ1bmN0aW9uIChlbnRyeSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoZW50cnkuaXNGaWxlKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZW50cnkuZmlsZShmdW5jdGlvbiAoZmlsZSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cGFyZW50RGlyZWN0b3J5LnVwbG9hZEZpbGVzLnB1c2goZmlsZSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBBZGQgdGhlIGZpbGVJZCB0byB0aGUgZmlsZSBuYW1lLCB0byBiZSBzdHJpcHBlZCBzZXJ2ZXItc2lkZVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dmFyIG5ld0ZpbGUgPSBuZXcgUGFyc2VyRmlsZShmaWxlSWQrKywgZmlsZS5uYW1lKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRpcmVjdG9yeS5maWxlcy5wdXNoKG5ld0ZpbGUpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIG5ld0ZpbGU7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSwgZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKGUpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHZhciBuZXdEaXJlY3RvcnkgPSBuZXcgUGFyc2VyRGlyZWN0b3J5KGVudHJ5Lm5hbWUsIFtdLCBbXSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gSWYgdGhpcyBpcyBpbnNpZGUgYSBkaXJlY3RvcnksIHB1dCBpdCBpbiB0aGVyZSFcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoZGlyZWN0b3J5KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkaXJlY3RvcnkuZGlyZWN0b3JpZXMucHVzaChuZXdEaXJlY3RvcnkpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkaXJlY3RvcnkgPSBuZXdEaXJlY3Rvcnk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBoYW5kbGVEaXJlY3RvcnkoZW50cnksIG5ld0RpcmVjdG9yeSwgdG9wRGlyZWN0b3J5KTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSkpKTtcblx0XHRcdFx0XHRcdFx0XHRcdC8vIENvbnRpbnVlIHJlYWRpbmcgZm9yIG1vcmUgZW50cmllc1xuXHRcdFx0XHRcdFx0XHRcdFx0cmVhZERpcmVjdG9yeShkaXJlY3RvcnksIHRvcERpcmVjdG9yeSk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdH0pKGRpcmVjdG9yeSwgdG9wRGlyZWN0b3J5KTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBldmVudCA9IGUub3JpZ2luYWxFdmVudDtcblx0XHRcdFx0aWYgKGV2ZW50KSB7XG5cdFx0XHRcdFx0dmFyIGRhdGFUcmFuc2ZlciA9IGV2ZW50LmRhdGFUcmFuc2Zlcjtcblx0XHRcdFx0XHR2YXIgaXRlbXMgPSBkYXRhVHJhbnNmZXIuaXRlbXM7XG5cdFx0XHRcdFx0dmFyIHBhcmVudERpcmVjdG9yeSA9IG5ldyBQYXJzZXJEaXJlY3RvcnkoKTtcblx0XHRcdFx0XHRwYXJlbnREaXJlY3RvcnkudXBsb2FkRmlsZXMgPSBbXTsgLy8gQWxsIG9mIHRoZSBmaWxlcyB0byB1cGxvYWRcblx0XHRcdFx0XHRpZiAoaXRlbXMubGVuZ3RoID09IDEpIHtcblx0XHRcdFx0XHRcdHZhciBpdGVtID0gaXRlbXNbMF0ud2Via2l0R2V0QXNFbnRyeSgpO1xuXHRcdFx0XHRcdFx0aWYgKGl0ZW0uaXNGaWxlKSB7XG5cdFx0XHRcdFx0XHRcdGhhbmRsZUZpbGVzKGl0ZW1zKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHBhcmVudERpcmVjdG9yeS5uYW1lID0gaXRlbS5uYW1lO1xuXHRcdFx0XHRcdFx0XHRoYW5kbGVEaXJlY3RvcnkoaXRlbSwgcGFyZW50RGlyZWN0b3J5LCBwYXJlbnREaXJlY3RvcnkpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuXHRcdFx0XHRcdFx0XHRcdG5vdGlmeURpcmVjdG9yeURvbmUocmVzdWx0KTtcblx0XHRcdFx0XHRcdFx0fSwgb25FcnJvcik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGhhbmRsZUZpbGVzKGl0ZW1zKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmdW5jdGlvbiBoYW5kbGVGaWxlcyhpdGVtcykge1xuXHRcdFx0XHRcdHZhciB3ZWJraXRJdGVtcyA9IFtdO1xuXHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdHdlYmtpdEl0ZW1zLnB1c2goaXRlbXNbaV0ud2Via2l0R2V0QXNFbnRyeSgpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gTmVlZCB0byB3cmFwIHRoaXMgaW4gYW4gZW1wdHkgZGlyZWN0b3J5XG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG5cdFx0XHRcdFx0XHR2YXIgaXRlcmF0aW9uQXR0ZW1wdHMgPSBbXTtcblx0XHRcdFx0XHRcdGl0ZXJhdGlvbkF0dGVtcHRzLnB1c2goUHJvbWlzZS5hbGwod2Via2l0SXRlbXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChpdGVtLmlzRmlsZSkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0aXRlbS5maWxlKGZ1bmN0aW9uIChmaWxlKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHBhcmVudERpcmVjdG9yeS51cGxvYWRGaWxlcy5wdXNoKGZpbGUpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBBZGQgdGhlIGZpbGVJZCB0byB0aGUgZmlsZSBuYW1lLCB0byBiZSBzdHJpcHBlZCBzZXJ2ZXItc2lkZVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR2YXIgbmV3RmlsZSA9IG5ldyBQYXJzZXJGaWxlKGZpbGVJZCsrLCBmaWxlLm5hbWUpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRwYXJlbnREaXJlY3RvcnkuZmlsZXMucHVzaChuZXdGaWxlKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZShwYXJlbnREaXJlY3RvcnkpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gbmV3RmlsZTtcblx0XHRcdFx0XHRcdFx0XHRcdH0sIG9uRXJyb3IpO1xuXHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHZhciBuZXdEaXJlY3RvcnkgPSBuZXcgUGFyc2VyRGlyZWN0b3J5KGl0ZW0ubmFtZSwgW10sIFtdKTtcblx0XHRcdFx0XHRcdFx0XHQvLyBJZiB0aGlzIGlzIGluc2lkZSBhIGRpcmVjdG9yeSwgcHV0IGl0IGluIHRoZXJlIVxuXHRcdFx0XHRcdFx0XHRcdGlmIChwYXJlbnREaXJlY3RvcnkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHBhcmVudERpcmVjdG9yeS5kaXJlY3Rvcmllcy5wdXNoKG5ld0RpcmVjdG9yeSk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdHBhcmVudERpcmVjdG9yeSA9IG5ld0RpcmVjdG9yeTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGhhbmRsZURpcmVjdG9yeShpdGVtLCBuZXdEaXJlY3RvcnksIHBhcmVudERpcmVjdG9yeSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0pKSk7XG5cdFx0XHRcdFx0XHRQcm9taXNlLmFsbChpdGVyYXRpb25BdHRlbXB0cykudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG5cdFx0XHRcdFx0XHRcdC8vIEV2ZXJ5dGhpbmcgc2hvdWxkIGJlIGRvbmUgbm93IVxuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKHBhcmVudERpcmVjdG9yeSk7XG5cdFx0XHRcdFx0XHR9LCBvbkVycm9yKTtcblx0XHRcdFx0XHR9KS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcblx0XHRcdFx0XHRcdG5vdGlmeURpcmVjdG9yeURvbmUocmVzdWx0KTtcblx0XHRcdFx0XHR9LCBvbkVycm9yKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZ1bmN0aW9uIG5vdGlmeURpcmVjdG9yeURvbmUoZmlsZSkge1xuXHRcdFx0XHRcdHNjb3BlLmRyYWdvdmVyQ2xhc3MgPSAnZHJvcHBlZCc7XG5cdFx0XHRcdFx0c2NvcGUuZHJhZ0FyZWFNZXNzYWdlID0gJ1JlYWR5IGZvciBVcGxvYWQhJztcblx0XHRcdFx0XHRzY29wZS4kYXBwbHkoKTtcblx0XHRcdFx0XHRzY29wZS5maWxlc0Ryb3BwZWQoZmlsZSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0sXG5cdFx0dGVtcGxhdGVVcmw6ICdwYXJzZXIvZmlsZVVwbG9hZC5odG1sJ1xuXHR9O1xufV0pOyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXHJcbiAqIENyZWF0ZWQgYnkgRWR3YXJkIG9uIDIvMjYvMjAxNi5cclxuICovXG5cbmFuZ3VsYXIubW9kdWxlKCdtY25lZHdhcmQnKS5jb250cm9sbGVyKCdQYXJzZXJDdHJsJywgWyckcm9vdFNjb3BlJywgJyRzY29wZScsICckd2luZG93JywgJ3BhcnNlclNlcnZpY2UnLCAncmVjYXB0Y2hhU2VydmljZScsICdtb2RhbFNlcnZpY2UnLCBmdW5jdGlvbiBQYXJzZXJDdHJsKCRyb290U2NvcGUsICRzY29wZSwgJHdpbmRvdywgcGFyc2VyU2VydmljZSwgcmVjYXB0Y2hhU2VydmljZSwgbW9kYWxTZXJ2aWNlKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBpZiAoL0FuZHJvaWR8d2ViT1N8aVBob25lfGlQYWR8aVBvZHxCbGFja0JlcnJ5fElFTW9iaWxlfE9wZXJhIE1pbmkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG4gICAgbW9kYWxTZXJ2aWNlLnNob3dNb2RhbCgnZGV2aWNlTW9kYWwnKTtcbiAgfVxuXG4gICRzY29wZS51cGxvYWRJbmZvID0ge307XG4gICRzY29wZS5pc0Zvcm1TdWJtaXR0ZWQgPSBmYWxzZTtcbiAgJHNjb3BlLmlzUGFyc2luZ0NvbXBsZXRlID0gZmFsc2U7XG4gICRzY29wZS5maWxlVXBsb2FkTWVzc2FnZSA9IFwiQ2xpY2sgdG8gY2hvb3NlIGEgSmF2YSBmaWxlIG9yIHByb2plY3QgdG8gcGFyc2UhXCI7XG4gICRzY29wZS5lcnJvck1lc3NhZ2UgPSBcIlwiO1xuICAkc2NvcGUuZmlsZVNlbGVjdGVkID0gZmFsc2U7XG4gIHZhciBlcnJvclBhcnNpbmdNZXNzYWdlID0gXCJTb21ldGhpbmcgd2VudCB3cm9uZyBwYXJzaW5nIGZpbGVzLi4uUGxlYXNlIHRyeSBhZ2Fpbi5cIjtcbiAgdmFyIGVycm9yVXBsb2FkaW5nTWVzc2FnZSA9IFwiU29tZXRoaW5nIHdlbnQgd3JvbmcgdXBsb2FkaW5nIGZpbGVzLi4uUGxlYXNlIHRyeSBhZ2Fpbi5cIjtcblxuICAkKCcjZmlsZS11cGxvYWQnKS5jaGFuZ2UoZnVuY3Rpb24gKCkge1xuICAgIHZhciBmaWxlcyA9IHRoaXMuZmlsZXM7XG4gICAgaWYgKCFmaWxlcyB8fCBmaWxlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnNvbGUubG9nKCdObyBmaWxlcyBzZWxlY3RlZC4uLicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgZmlsZU5hbWUgPSBmaWxlc1swXS5uYW1lO1xuICAgICRzY29wZS5maWxlcyA9IGZpbGVzO1xuXG4gICAgJHNjb3BlLmZpbGVOYW1lID0gZmlsZU5hbWU7XG4gICAgJHNjb3BlLmZpbGVTZWxlY3RlZCA9IHRydWU7XG4gICAgJHNjb3BlLiRhcHBseSgpO1xuICB9KTtcblxuICBmdW5jdGlvbiBlcnJvckhhbmRsZXIobWVzc2FnZSwgZXJyb3IpIHtcbiAgICB2YXIgZXJyb3JNZXNzYWdlID0gJyc7XG4gICAgdmFyIGRhdGEgPSBlcnJvciAmJiBlcnJvci5kYXRhID8gZXJyb3IuZGF0YSA6IG51bGwsXG4gICAgICAgIGVycm9ycyA9IGRhdGEgJiYgZGF0YS5lcnJvcnMgPyBkYXRhLmVycm9ycyA6IFtdO1xuICAgIGlmIChlcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlcnJvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZXJyb3JNZXNzYWdlICs9IGVycm9yc1tpXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZXJyb3JNZXNzYWdlID0gbWVzc2FnZTtcbiAgICB9XG4gICAgJHNjb3BlLmhhbmRsZUVycm9yKGVycm9yTWVzc2FnZSwgZXJyb3IpO1xuICAgICRzY29wZS5wYXJzaW5nQ29tcGxldGUgPSBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwbG9hZEZpbGVzKHNlY3JldFJlc3BvbnNlLCB0b2tlbikge1xuICAgICRzY29wZS5zZWNyZXRSZXNwb25zZSA9IHNlY3JldFJlc3BvbnNlO1xuICAgICRzY29wZS50b2tlbiA9IHRva2VuO1xuXG4gICAgcGFyc2VyU2VydmljZS51cGxvYWRGaWxlcygkc2NvcGUuZmlsZXMsIHNlY3JldFJlc3BvbnNlLCB0b2tlbikudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgcmVzcG9uc2UudGV4dCgpLnRoZW4oZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgICBlcnJvckhhbmRsZXIodGV4dCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXNwb25zZS5qc29uKCkudGhlbihmdW5jdGlvbiAodXBsb2FkUmVzcG9uc2UpIHtcbiAgICAgICAgJHNjb3BlLnVwbG9hZERpcmVjdG9yeS50b2tlbiA9IHVwbG9hZFJlc3BvbnNlLnRva2VuO1xuICAgICAgICAkc2NvcGUudXBsb2FkRGlyZWN0b3J5LmZpbGVJZHMgPSB1cGxvYWRSZXNwb25zZS5maWxlSWRzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFNlbmQgYmFjayB0aGUgdXBsb2FkUmVzcG9uc2UgYWxvbmcgd2l0aCB0aGUgZGlyZWN0b3J5IHN0cnVjdHVyZVxuICAgICAgICAgIC8vIFRoaXMgaXMgd2hlbiB0aGUgYWN0dWFsIHBhcnNpbmcgb2YgdGhlIGZpbGVzIHdpbGwgaGFwcGVuXG4gICAgICAgICAgcGFyc2VyU2VydmljZS5wYXJzZUZpbGVzKCRzY29wZS51cGxvYWREaXJlY3RvcnksIHNlY3JldFJlc3BvbnNlLCB0b2tlbikudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgcmVzcG9uc2UudGV4dCgpLnRoZW4oZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgICAgICAgICBlcnJvckhhbmRsZXIodGV4dCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICRzY29wZS5kcmFnQXJlYU1lc3NhZ2UgPSAnQW5hbHl6aW5nIHlvdXIgZmlsZXMuLi4nO1xuICAgICAgICAgICAgICAkc2NvcGUuJGFwcGx5KCk7XG4gICAgICAgICAgICAgIHJlc3BvbnNlLmpzb24oKS50aGVuKGZ1bmN0aW9uIChkaXJlY3RvcnlSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHBhcnNlclNlcnZpY2Uuc2F2ZURpcmVjdG9yeShkaXJlY3RvcnlSZXNwb25zZSk7XG5cbiAgICAgICAgICAgICAgICAkc2NvcGUubG9hZChmYWxzZSk7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmZpbGVTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICRzY29wZS5pc1BhcnNpbmdDb21wbGV0ZSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAkc2NvcGUudXBsb2FkRGlyZWN0b3J5ID0ge307XG4gICAgICAgICAgICAgICAgJHNjb3BlLmRpcmVjdG9yeSA9IGRpcmVjdG9yeVJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIHZhciBjbGFzc09iamVjdCA9IGZpbmRGaXJzdEZpbGVJbkRpcmVjdG9yeShkaXJlY3RvcnlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmNsYXNzT2JqZWN0ID0gY2xhc3NPYmplY3Q7XG4gICAgICAgICAgICAgICAgc3R5bGVMaW5lTnVtYmVycyhjbGFzc09iamVjdCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgZXJyb3JIYW5kbGVyKGVycm9yUGFyc2luZ01lc3NhZ2UsIGVycm9yKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBlcnJvckhhbmRsZXIoZXJyb3JQYXJzaW5nTWVzc2FnZSwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gICRzY29wZS51cGxvYWRGaWxlID0gZnVuY3Rpb24gKGZvcm0sIHVwbG9hZEluZm8pIHtcbiAgICBpZiAoJHNjb3BlLmlzRm9ybVN1Ym1pdHRlZCkgcmV0dXJuO1xuICAgIGZvcm0uJHNldFN1Ym1pdHRlZCgpO1xuICAgIGlmIChmb3JtLiRpbnZhbGlkKSByZXR1cm47XG4gICAgJHNjb3BlLmlzRm9ybVN1Ym1pdHRlZCA9IHRydWU7XG4gICAgZm9ybS4kc2V0UHJpc3RpbmUoKTtcbiAgICBmb3JtLiRzZXRVbnRvdWNoZWQoKTtcbiAgICAkc2NvcGUubG9hZCh0cnVlKTtcbiAgICAkc2NvcGUuZHJhZ0FyZWFNZXNzYWdlID0gJ1VwbG9hZGluZyB5b3VyIGZpbGVzLi4uJztcbiAgICByZWNhcHRjaGFTZXJ2aWNlLnZlcmlmeSh1cGxvYWRJbmZvLnJlY2FwdGNoYVJlc3BvbnNlLCB1cGxvYWRGaWxlcywgZXJyb3JIYW5kbGVyKTtcbiAgfTtcblxuICAkc2NvcGUuc2VsZWN0Q2xhc3NPYmplY3QgPSBmdW5jdGlvbiAoZmlsZSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgJHNjb3BlLmNsYXNzT2JqZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNPYmplY3QgPSAkc2NvcGUuY2xhc3NPYmplY3RzW2ldO1xuICAgICAgaWYgKGNPYmplY3QuZmlsZU5hbWUgPT09IGZpbGUuZmlsZU5hbWUpIHtcbiAgICAgICAgJHNjb3BlLmNsYXNzT2JqZWN0ID0gY09iamVjdDtcbiAgICAgIH1cbiAgICAgIC8vIFRoaXMgc2hvdWxkIGJlIHNhZmUgc2luY2Ugd2Ugc2hvdWxkIGFsd2F5cyBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiBmaWxlTmFtZXMgYW5kIGNsYXNzT2JqZWN0c1xuICAgICAgJHNjb3BlLmZpbGVOYW1lc1tpXS5pc1NlbGVjdGVkID0gZmFsc2U7XG4gICAgfVxuICAgIGZpbGUuaXNTZWxlY3RlZCA9IHRydWU7XG4gICAgc3R5bGVMaW5lTnVtYmVycygkc2NvcGUuY2xhc3NPYmplY3QpO1xuICB9O1xuXG4gICRzY29wZS5maWxlc0Ryb3BwZWQgPSBmdW5jdGlvbiAoZGlyZWN0b3J5KSB7XG4gICAgJHNjb3BlLmZpbGVOYW1lID0gZGlyZWN0b3J5Lm5hbWUgPyBkaXJlY3RvcnkubmFtZSA6IGRpcmVjdG9yeS51cGxvYWRGaWxlcy5sZW5ndGggKyAnIEZpbGVzJztcbiAgICAkc2NvcGUuZmlsZXMgPSBkaXJlY3RvcnkudXBsb2FkRmlsZXM7XG4gICAgJHNjb3BlLmZpbGVTZWxlY3RlZCA9IHRydWU7XG4gICAgJHNjb3BlLnVwbG9hZERpcmVjdG9yeSA9IGRpcmVjdG9yeTtcbiAgICAkc2NvcGUuJGFwcGx5KCk7IC8vIE5lZWQgdG8gYXBwbHkgYmVjYXVzZSB0aGlzIGlzIGNvbWluZyBmcm9tIHRoZSBmaWxlVXBsb2FkRGlyZWN0aXZlXG4gIH07XG5cbiAgJHNjb3BlLm1vdmVUb0xpbmUgPSBmdW5jdGlvbiAoY29udGVudCkge1xuICAgIHZhciBsaW5lTnVtYmVyID0gY29udGVudC5saW5lTnVtYmVyO1xuICAgIHZhciBlbGVtZW50ID0gJCgnIycgKyBsaW5lTnVtYmVyKTtcbiAgICBlbGVtZW50LmFkZENsYXNzKCdsaW5lLWFuaW1hdGlvbi1pbicpO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgZWxlbWVudC5hZGRDbGFzcygnbGluZS1hbmltYXRpb24tb3V0Jyk7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVDbGFzcygnbGluZS1hbmltYXRpb24taW4nKTtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVDbGFzcygnbGluZS1hbmltYXRpb24tb3V0Jyk7XG4gICAgICB9LCAxNTAwKTtcbiAgICB9LCAzMDAwKTtcbiAgICAkKCcjY2xhc3NDb250ZW50JykuYW5pbWF0ZSh7XG4gICAgICBzY3JvbGxUb3A6IGVsZW1lbnQub2Zmc2V0KCkudG9wIC0gMjAwXG4gICAgfSwgNTAwKTtcbiAgfTtcbiAgJHJvb3RTY29wZS4kb24oJ3NlbGVjdENsYXNzJywgZnVuY3Rpb24gKGUsIGFyZ3MpIHtcbiAgICB2YXIgY2xhc3NPYmplY3QgPSBzZWFyY2hEaXJlY3RvcnkoJHNjb3BlLmRpcmVjdG9yeSwgYXJncy5kaXJlY3RvcnlJZCwgYXJncy5jbGFzc0lkKTtcbiAgICBpZiAoY2xhc3NPYmplY3QpIHtcbiAgICAgICRzY29wZS5jbGFzc09iamVjdCA9IGNsYXNzT2JqZWN0O1xuICAgICAgc3R5bGVMaW5lTnVtYmVycyhjbGFzc09iamVjdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICRzY29wZS5lcnJvck1lc3NhZ2UgPSAnQ291bGQgbm90IGZpbmQgY2xhc3MuJztcbiAgICB9XG4gIH0pO1xuICBmdW5jdGlvbiBzZWFyY2hEaXJlY3RvcnkoZGlyZWN0b3J5LCBkaXJlY3RvcnlJZCwgY2xhc3NJZCkge1xuICAgIHZhciBjbGFzc09iamVjdDtcbiAgICBpZiAoZGlyZWN0b3J5SWQgPT09IGRpcmVjdG9yeS5pZCkge1xuICAgICAgaWYgKGRpcmVjdG9yeS5jbGFzc2VzKSB7XG4gICAgICAgIGNsYXNzT2JqZWN0ID0gc2VhcmNoQ2xhc3Nlc0luRGlyZWN0b3J5KGRpcmVjdG9yeS5jbGFzc2VzLCBjbGFzc0lkKTtcbiAgICAgICAgaWYgKGNsYXNzT2JqZWN0KSByZXR1cm4gY2xhc3NPYmplY3Q7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlyZWN0b3J5LmRpcmVjdG9yaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGREaXJlY3RvcnkgPSBkaXJlY3RvcnkuZGlyZWN0b3JpZXNbaV07XG4gICAgICBjbGFzc09iamVjdCA9IHNlYXJjaERpcmVjdG9yeShjaGlsZERpcmVjdG9yeSwgZGlyZWN0b3J5SWQsIGNsYXNzSWQpO1xuICAgICAgaWYgKGNsYXNzT2JqZWN0KSByZXR1cm4gY2xhc3NPYmplY3Q7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHNlYXJjaENsYXNzZXNJbkRpcmVjdG9yeShjbGFzc2VzLCBjbGFzc0lkKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGFzc2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IGNsYXNzZXNbaV07XG4gICAgICBpZiAoYy5pZCA9PSBjbGFzc0lkKSB7XG4gICAgICAgIHJldHVybiBjO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBmaW5kRmlyc3RGaWxlSW5EaXJlY3RvcnkoZGlyZWN0b3J5KSB7XG4gICAgaWYgKGRpcmVjdG9yeS5jbGFzc2VzICYmIGRpcmVjdG9yeS5jbGFzc2VzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiBkaXJlY3RvcnkuY2xhc3Nlc1swXTtcbiAgICB9XG4gICAgaWYgKGRpcmVjdG9yeS5kaXJlY3Rvcmllcykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJlY3RvcnkuZGlyZWN0b3JpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2xhc3NPYmplY3QgPSBmaW5kRmlyc3RGaWxlSW5EaXJlY3RvcnkoZGlyZWN0b3J5LmRpcmVjdG9yaWVzW2ldKTtcbiAgICAgICAgaWYgKGNsYXNzT2JqZWN0KSByZXR1cm4gY2xhc3NPYmplY3Q7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gRk9SIERFQlVHR0lORyBQVVJQT1NFUyFcbiAgJHNjb3BlLmRpcmVjdG9yeSA9IHBhcnNlclNlcnZpY2UuZ2V0RGlyZWN0b3J5KCk7XG4gIGlmICgkc2NvcGUuZGlyZWN0b3J5KSB7XG4gICAgJHNjb3BlLmlzUGFyc2luZ0NvbXBsZXRlID0gdHJ1ZTtcbiAgICB2YXIgY2xhc3NPYmplY3QgPSBmaW5kRmlyc3RGaWxlSW5EaXJlY3RvcnkoJHNjb3BlLmRpcmVjdG9yeSk7XG4gICAgaWYgKGNsYXNzT2JqZWN0KSB7XG4gICAgICAkc2NvcGUuY2xhc3NPYmplY3QgPSBjbGFzc09iamVjdDtcbiAgICAgIHN0eWxlTGluZU51bWJlcnMoY2xhc3NPYmplY3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICAkc2NvcGUuZXJyb3JNZXNzYWdlID0gJ0NvdWxkIG5vdCBmaW5kIGFueSBmaWxlcyBpbiBkaXJlY3RvcnkgJyArICRzY29wZS5kaXJlY3RvcnkubmFtZSArICcuJztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXRGaWxlTmFtZXMoY2xhc3NPYmplY3RzKSB7XG4gICAgdmFyIGZpbGVOYW1lcyA9IFtdO1xuICAgIGFuZ3VsYXIuZm9yRWFjaChjbGFzc09iamVjdHMsIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICBmaWxlTmFtZXMucHVzaCh7XG4gICAgICAgIGZpbGVOYW1lOiB2YWx1ZS5maWxlTmFtZSxcbiAgICAgICAgaXNTZWxlY3RlZDogZmFsc2VcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgICRzY29wZS5maWxlTmFtZXMgPSBmaWxlTmFtZXM7XG4gIH1cblxuICAvLyBUaGFua3MgdG86IGh0dHBzOi8vanNmaWRkbGUubmV0L3RvdmljL0FicFJEL1xuICBmdW5jdGlvbiBzdHlsZUxpbmVOdW1iZXJzKGNsYXNzT2JqZWN0KSB7XG4gICAgdmFyIHByZTtcbiAgICAkKCcjY2xhc3NDb250ZW50JykuZW1wdHkoKTtcbiAgICBpZiAoY2xhc3NPYmplY3QuY29kZVRhZykge1xuICAgICAgcHJlID0gY2xhc3NPYmplY3QuY29kZVRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgcHJlID0gJCgnPGNvZGUvPicsIHtcbiAgICAgICAgaWQ6ICdjb2RlJyxcbiAgICAgICAgdGV4dDogY2xhc3NPYmplY3QuY2xhc3NDb250ZW50XG4gICAgICB9KTtcbiAgICAgIHZhciBwcmVMZW5ndGggPSBwcmUubGVuZ3RoO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmVMZW5ndGg7IGkrKykge1xuICAgICAgICBwcmVbaV0uaW5uZXJIVE1MID0gJzxzcGFuIGNsYXNzPVwibGluZS1udW1iZXJcIj48L3NwYW4+JyArIHByZVtpXS5pbm5lckhUTUwgKyAnPHNwYW4gY2xhc3M9XCJjbFwiPjwvc3Bhbj4nO1xuICAgICAgICB2YXIgbnVtID0gcHJlW2ldLmlubmVySFRNTC5zcGxpdCgvXFxuLykubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG51bTsgaisrKSB7XG4gICAgICAgICAgdmFyIGxpbmVOdW1iZXJFbGVtZW50ID0gcHJlW2ldLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzcGFuJylbMF07XG4gICAgICAgICAgdmFyIG51bWJlciA9IGogKyAxO1xuICAgICAgICAgIGxpbmVOdW1iZXJFbGVtZW50LmlubmVySFRNTCArPSAnPHNwYW4gaWQ9XCInICsgbnVtYmVyICsgJ1wiPicgKyBudW1iZXIgKyAnPC9zcGFuPic7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIENhY2hlIHRoZSBjb2RlIHRhZyB0byBhdm9pZCBwYXJzaW5nIGFnYWluIGZvciBtdWx0aXBsZSBzZWxlY3RzXG4gICAgICBjbGFzc09iamVjdC5jb2RlVGFnID0gcHJlO1xuICAgIH1cbiAgICBwcmUuYXBwZW5kVG8oJyNjbGFzc0NvbnRlbnQnKTtcbiAgfVxufV0pOyIsIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBQYXJzZXJEaXJlY3RvcnkobmFtZSwgZGlyZWN0b3JpZXMsIGZpbGVzKSB7XG5cdHZhciBzZWxmID0gdGhpcztcblx0c2VsZi5uYW1lID0gbmFtZSA/IG5hbWUgOiBudWxsO1xuXHRzZWxmLmRpcmVjdG9yaWVzID0gZGlyZWN0b3JpZXMgPyBkaXJlY3RvcmllcyA6IFtdO1xuXHRzZWxmLmZpbGVzID0gZmlsZXMgPyBmaWxlcyA6IFtdO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBQYXJzZXJGaWxlKGlkLCBuYW1lKSB7XG5cdHZhciBzZWxmID0gdGhpcztcblx0c2VsZi5pZCA9IGlkID8gaWQgOiAwO1xuXHRzZWxmLm5hbWUgPSBuYW1lID8gbmFtZSA6IG51bGw7XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcclxuICogQ3JlYXRlZCBieSBFZHdhcmQgb24gMi8yNi8yMDE2LlxyXG4gKi9cbmFuZ3VsYXIubW9kdWxlKCdtY25lZHdhcmQnKS5zZXJ2aWNlKCdwYXJzZXJTZXJ2aWNlJywgWyckaHR0cCcsIGZ1bmN0aW9uICgkaHR0cCkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIHBhcnNlclNlcnZpY2UgPSB7fTtcblxuXHRwYXJzZXJTZXJ2aWNlLnVwbG9hZEZpbGVzID0gZnVuY3Rpb24gKGZpbGVzLCBzZWNyZXRSZXNwb25zZSwgdG9rZW4pIHtcblx0XHR2YXIgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcblx0XHRhbmd1bGFyLmZvckVhY2goZmlsZXMsIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG5cdFx0XHRmb3JtRGF0YS5hcHBlbmQoJ2ZpbGVzJywgdmFsdWUpO1xuXHRcdH0pO1xuXG5cdFx0dmFyIHVybCA9ICcvYXBpL3BhcnNlci9maWxlcz9zZWNyZXRSZXNwb25zZT0nICsgc2VjcmV0UmVzcG9uc2UgKyAnJnJlcXVlc3RUb2tlbj0nICsgdG9rZW47XG5cdFx0cmV0dXJuIGZldGNoKHVybCwge1xuXHRcdFx0bWV0aG9kOiAnUE9TVCcsXG5cdFx0XHRib2R5OiBmb3JtRGF0YVxuXHRcdH0pO1xuXHR9O1xuXG5cdHBhcnNlclNlcnZpY2UucGFyc2VGaWxlcyA9IGZ1bmN0aW9uIChkaXJlY3RvcnksIHNlY3JldFJlc3BvbnNlLCB0b2tlbikge1xuXHRcdGRpcmVjdG9yeS51cGxvYWRGaWxlcyA9IG51bGw7XG5cdFx0dmFyIHVybCA9ICcvYXBpL3BhcnNlci9wYXJzZT9zZWNyZXRSZXNwb25zZT0nICsgc2VjcmV0UmVzcG9uc2UgKyAnJnJlcXVlc3RUb2tlbj0nICsgdG9rZW47XG5cdFx0cmV0dXJuIGZldGNoKHVybCwge1xuXHRcdFx0bWV0aG9kOiAnUE9TVCcsXG5cdFx0XHRoZWFkZXJzOiB7XG5cdFx0XHRcdCdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbicsXG5cdFx0XHRcdCdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcblx0XHRcdH0sXG5cdFx0XHRib2R5OiBKU09OLnN0cmluZ2lmeShkaXJlY3RvcnkpXG5cdFx0fSk7XG5cdH07XG5cblx0cGFyc2VyU2VydmljZS5nZXRVcGxvYWRQcm9ncmVzcyA9IGZ1bmN0aW9uIChzZWNyZXRSZXNwb25zZSwgdG9rZW4sIHJlc3BvbnNlRnVuY3Rpb24pIHtcblx0XHRyZXR1cm4gZmV0Y2goJy9hcGkvcGFyc2VyL3Byb2dyZXNzP3NlY3JldFJlc3BvbnNlPScgKyBzZWNyZXRSZXNwb25zZSArICcmcmVxdWVzdFRva2VuPScgKyB0b2tlbik7XG5cdH07XG5cblx0cGFyc2VyU2VydmljZS5zYXZlQ2xhc3NlcyA9IGZ1bmN0aW9uIChjbGFzc09iamVjdHMpIHtcblx0XHRpZiAoY2xhc3NPYmplY3RzKSB7XG5cdFx0XHRsb2NhbFN0b3JhZ2UuY2xhc3NPYmplY3RzID0gSlNPTi5zdHJpbmdpZnkoY2xhc3NPYmplY3RzKTtcblx0XHRcdHBhcnNlclNlcnZpY2UuY2xhc3NPYmplY3RzID0gY2xhc3NPYmplY3RzO1xuXHRcdH0gZWxzZSBjb25zb2xlLmxvZygnTm8gY2xhc3NPYmplY3RzIHRvIHNhdmUuLi4nKTtcblx0fTtcblx0cGFyc2VyU2VydmljZS5nZXRDbGFzc2VzID0gZnVuY3Rpb24gKCkge1xuXHRcdHZhciBjbGFzc09iamVjdHMgPSBsb2NhbFN0b3JhZ2UuY2xhc3NPYmplY3RzID8gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuY2xhc3NPYmplY3RzKSA6IG51bGw7XG5cdFx0cmV0dXJuIGNsYXNzT2JqZWN0cztcblx0fTtcblxuXHRwYXJzZXJTZXJ2aWNlLnNhdmVEaXJlY3RvcnkgPSBmdW5jdGlvbiAoZGlyZWN0b3J5KSB7XG5cdFx0aWYgKGRpcmVjdG9yeSkge1xuXHRcdFx0bG9jYWxTdG9yYWdlLmRpcmVjdG9yeSA9IEpTT04uc3RyaW5naWZ5KGRpcmVjdG9yeSk7XG5cdFx0XHRwYXJzZXJTZXJ2aWNlLmRpcmVjdG9yeSA9IGRpcmVjdG9yeTtcblx0XHR9IGVsc2UgY29uc29sZS5sb2coJ05vIGRpcmVjdG9yeSB0byBzYXZlLi4uJyk7XG5cdH07XG5cdHBhcnNlclNlcnZpY2UuZ2V0RGlyZWN0b3J5ID0gZnVuY3Rpb24gKCkge1xuXHRcdHZhciBkaXJlY3RvcnkgPSBsb2NhbFN0b3JhZ2UuZGlyZWN0b3J5ID8gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZGlyZWN0b3J5KSA6IG51bGw7XG5cdFx0cmV0dXJuIGRpcmVjdG9yeTtcblx0fTtcblxuXHRyZXR1cm4gcGFyc2VyU2VydmljZTtcbn1dKTsiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxyXG4gKiBDcmVhdGVkIGJ5IEVkd2FyZCBvbiAyLzI4LzIwMTYuXHJcbiAqL1xuXG5hbmd1bGFyLm1vZHVsZSgnbWNuZWR3YXJkJykuZGlyZWN0aXZlKCdzdHJ1Y3R1cmUnLCBbJyRyb290U2NvcGUnLCBmdW5jdGlvbiAoJHJvb3RTY29wZSkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0cmV0dXJuIHtcblx0XHRyZXN0cmljdDogJ0UnLFxuXHRcdHRyYW5zY2x1ZGU6IHRydWUsXG5cdFx0c2NvcGU6IHtcblx0XHRcdHRpdGxlOiAnQCcsXG5cdFx0XHRjb250ZW50czogJz0nXG5cdFx0fSxcblx0XHRjb250cm9sbGVyOiBmdW5jdGlvbiBjb250cm9sbGVyKCRzY29wZSwgJGVsZW1lbnQsICR0aW1lb3V0KSB7fSxcblx0XHRsaW5rOiBmdW5jdGlvbiBsaW5rKHNjb3BlLCBlbGVtZW50LCBhdHRycykge30sXG5cdFx0dGVtcGxhdGVVcmw6ICdwYXJzZXIvc3RydWN0dXJlLmh0bWwnXG5cdH07XG59XSk7IiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcclxuICogQ3JlYXRlZCBieSBFZHdhcmQgb24gMTAvMTgvMjAxNC5cclxuICovXG5hbmd1bGFyLm1vZHVsZSgnbWNuZWR3YXJkJykuZmFjdG9yeSgnbW9kYWxTZXJ2aWNlJywgWyckdGltZW91dCcsIGZ1bmN0aW9uICgkdGltZW91dCkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIG1vZGFsU2VydmljZSA9IHt9O1xuXHR2YXIgb3ZlcmxheSwgbW9kYWwsIGNsb3NlO1xuXG5cdGZ1bmN0aW9uIHJlbW92ZU1vZGFsKGhhc1BlcnNwZWN0aXZlKSB7XG5cdFx0Y2xhc3NpZS5yZW1vdmUobW9kYWwsICdtZC1zaG93Jyk7XG5cdH1cblxuXHRmdW5jdGlvbiByZW1vdmVNb2RhbEhhbmRsZXIoKSB7XG5cdFx0cmVtb3ZlTW9kYWwoKTtcblx0fVxuXG5cdG1vZGFsU2VydmljZS5zaG93TW9kYWwgPSBmdW5jdGlvbiAobW9kYWxJZCkge1xuXHRcdG1vZGFsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignIycgKyBtb2RhbElkKTtcblx0XHRjbGFzc2llLmFkZChtb2RhbCwgJ21kLXNob3cnKTtcblxuXHRcdG92ZXJsYXkgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjb3ZlcmxheS0nICsgbW9kYWxJZCk7XG5cdFx0b3ZlcmxheS5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHJlbW92ZU1vZGFsSGFuZGxlcik7XG5cdFx0b3ZlcmxheS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHJlbW92ZU1vZGFsSGFuZGxlcik7XG5cblx0XHRjbG9zZSA9IG1vZGFsLnF1ZXJ5U2VsZWN0b3IoJy5jYW5jZWwtYnRuJyk7XG5cdFx0Y2xvc2UuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoZXYpIHtcblx0XHRcdGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0cmVtb3ZlTW9kYWxIYW5kbGVyKCk7XG5cdFx0fSk7XG5cdH07XG5cdG1vZGFsU2VydmljZS5jbG9zZU1vZGFsID0gZnVuY3Rpb24gKCkge1xuXHRcdHJlbW92ZU1vZGFsSGFuZGxlcigpO1xuXHR9O1xuXHRtb2RhbFNlcnZpY2UuaXNPcGVuID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBtb2RhbCAhPT0gdW5kZWZpbmVkO1xuXHR9O1xuXG5cdGZ1bmN0aW9uIHNob3dMb2FkaW5nKHNob3cpIHtcblx0XHR2YXIgbG9hZGluZ0RpdiA9ICQoJyNwYWdlTG9hZGVyJyk7XG5cdFx0aWYgKHNob3cpIHtcblx0XHRcdGxvYWRpbmdEaXYuc2hvdygpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRsb2FkaW5nRGl2LmhpZGUoKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbW9kYWxTZXJ2aWNlO1xufV0pOyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXHJcbiAqIENyZWF0ZWQgYnkgRWR3YXJkIG9uIDEwLzE1LzIwMTYuXHJcbiAqL1xuYW5ndWxhci5tb2R1bGUoJ21jbmVkd2FyZCcpLmZhY3RvcnkoJ3JlY2FwdGNoYVNlcnZpY2UnLCBmdW5jdGlvbiAoKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgcmVjYXB0Y2hhU2VydmljZSA9IHt9O1xuXG4gIHJlY2FwdGNoYVNlcnZpY2UudmVyaWZ5ID0gZnVuY3Rpb24gKHNlY3JldFJlc3BvbnNlLCBzdWNjZXNzQ2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spIHtcbiAgICBpZiAoc2VjcmV0UmVzcG9uc2UgPT09IG51bGwpIHtcbiAgICAgIGVycm9yQ2FsbGJhY2soJ1NvcnJ5LCBidXQgc29tZXRoaW5nIHdlbnQgd3Jvbmcgd2l0aCB0aGUgcmVDYXB0Y2hhLiBQbGVhc2UgcmVmcmVzaCB0aGUgcGFnZSBhbmQgdHJ5IGFnYWluLicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmZXRjaCgnL2FwaS9yZWNhcHRjaGEvdmVyaWZ5P3NlY3JldFJlc3BvbnNlPScgKyBzZWNyZXRSZXNwb25zZSwgeyBtZXRob2Q6ICdQT1NUJyB9KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgdmFyIG9rID0gcmVzcG9uc2Uub2s7XG4gICAgICByZXNwb25zZS50ZXh0KCkudGhlbihmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICBpZiAob2spIHtcbiAgICAgICAgICBzdWNjZXNzQ2FsbGJhY2soc2VjcmV0UmVzcG9uc2UsIHRleHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVycm9yQ2FsbGJhY2sodGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiByZWNhcHRjaGFTZXJ2aWNlO1xufSk7IiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcclxuICogQ3JlYXRlZCBieSBFZHdhcmQgb24gNi85LzIwMTYuXHJcbiAqL1xuYW5ndWxhci5tb2R1bGUoJ21jbmVkd2FyZCcpLmZhY3RvcnkoJ3VzZXJTZXJ2aWNlJywgW2Z1bmN0aW9uICgpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciB1c2VyU2VydmljZSA9IHt9O1xuXHR2YXIgc2F2ZWRVc2VyID0gbnVsbDtcblxuXHR1c2VyU2VydmljZS5jbGVhckNhY2hlID0gZnVuY3Rpb24gKCkge1xuXHRcdGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCd1c2VyJyk7XG5cdFx0dGhpcy5zYXZlZFVzZXIgPSBudWxsO1xuXHR9O1xuXG5cdHVzZXJTZXJ2aWNlLmlzTG9nZ2VkSW4gPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0QXV0aFRva2VuKCkgIT09IG51bGw7XG5cdH07XG5cblx0dXNlclNlcnZpY2UuaXNBZG1pbiA9IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuc2F2ZWRVc2VyKSB0aGlzLmdldFVzZXIoKTtcblx0XHRpZiAodGhpcy5zYXZlZFVzZXIudXNlclJvbGVzICYmIHRoaXMuc2F2ZWRVc2VyLnVzZXJSb2xlcy5pbmRleE9mKCdBRE1JTicpICE9IC0xKSByZXR1cm4gdHJ1ZTtlbHNlIHJldHVybiBmYWxzZTtcblx0fTtcblxuXHR1c2VyU2VydmljZS5zYXZlID0gZnVuY3Rpb24gKHVzZXIpIHtcblx0XHRpZiAodXNlciAmJiB1c2VyLmF1dGhUb2tlbiAhPT0gJycpIHtcblx0XHRcdGxvY2FsU3RvcmFnZS51c2VyID0gSlNPTi5zdHJpbmdpZnkodXNlcik7XG5cdFx0XHR0aGlzLnNhdmVkVXNlciA9IHVzZXI7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnNvbGUubG9nKCdObyB1c2VyIHRvIHNhdmUuJyk7XG5cdFx0fVxuXHR9O1xuXG5cdHVzZXJTZXJ2aWNlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLnNhdmUodGhpcy5nZXRVc2VyKCkpO1xuXHR9O1xuXG5cdHVzZXJTZXJ2aWNlLmdldFVzZXIgPSBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLnNhdmVkVXNlcikge1xuXHRcdFx0dGhpcy5zYXZlZFVzZXIgPSBsb2NhbFN0b3JhZ2UudXNlciA/IEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLnVzZXIpIDogW107XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLnNhdmVkVXNlcjtcblx0fTtcblxuXHR1c2VyU2VydmljZS5nZXRBdXRoVG9rZW4gPSBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLnNhdmVkVXNlcikgdGhpcy5nZXRVc2VyKCk7XG5cdFx0aWYgKHRoaXMuc2F2ZWRVc2VyLmF1dGhUb2tlbiAmJiB0aGlzLnNhdmVkVXNlci5hdXRoVG9rZW4gIT09ICcnKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5zYXZlZFVzZXIuYXV0aFRva2VuO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdH07XG5cblx0cmV0dXJuIHVzZXJTZXJ2aWNlO1xufV0pOyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXHJcbiAqIENyZWF0ZWQgYnkgRWR3YXJkIG9uIDIvMTkvMTUuXHJcbiAqL1xuYW5ndWxhci5tb2R1bGUoJ21jbmVkd2FyZCcpLmRpcmVjdGl2ZSgnYnV0dG9ub3B0aW9ucycsIFtmdW5jdGlvbiAoKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHRyZXR1cm4ge1xuXHRcdHNjb3BlOiB7XG5cdFx0XHRjb25maXJtQWN0aW9uOiAnJicsXG5cdFx0XHRjYW5jZWxBY3Rpb246ICcmJ1xuXHRcdH0sXG5cdFx0cmVzdHJpY3Q6ICdBRScsXG5cdFx0cmVwbGFjZTogJ3RydWUnLFxuXHRcdGNvbnRyb2xsZXI6IGZ1bmN0aW9uIGNvbnRyb2xsZXIoJHNjb3BlKSB7XG5cdFx0XHQkc2NvcGUuY29uZmlybSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0JHNjb3BlLmNvbmZpcm1BY3Rpb24oKTtcblx0XHRcdH07XG5cdFx0XHQkc2NvcGUuY2FuY2VsID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHQkc2NvcGUuY2FuY2VsQWN0aW9uKCk7XG5cdFx0XHR9O1xuXHRcdH0sXG5cdFx0bGluazogZnVuY3Rpb24gbGluayhzY29wZSwgZWxlbWVudCwgYXR0cnMpIHtcblx0XHRcdHNjb3BlLnRpdGxlID0gYXR0cnMuY29uZmlybVRpdGxlO1xuXHRcdFx0c2NvcGUuY2FuY2VsVGl0bGUgPSBhdHRycy5jYW5jZWxUaXRsZSA/IGF0dHJzLmNhbmNlbFRpdGxlIDogJ1gnO1xuXHRcdFx0aWYgKGF0dHJzLmNvbmZpcm1DbGFzcykgc2NvcGUuY29uZmlybUNsYXNzID0gYXR0cnMuY29uZmlybUNsYXNzO1xuXHRcdH0sXG5cdFx0Ly8gdGVtcGxhdGU6ICc8ZGl2IGNsYXNzPVwiYnV0dG9uLWRpdlwiPjxzcGFuIGlkPVwiY29uZmlybUJ0blwiIGNsYXNzPVwiZWJ0biBlYnRuLWdyZWVuIGNvbmZpcm1CdG5cIiBuZy1jbGljaz1cImNvbmZpcm0oKVwiIG5nLWNsYXNzPVwiY29uZmlybUNsYXNzXCIgc3R5bGU9XCJ3aWR0aDo3NSU7d2hpdGUtc3BhY2U6bm93cmFwO3RleHQtb3ZlcmZsb3c6ZWxscHNpcztcIj57e3RpdGxlfX08L3NwYW4+PHNwYW4gY2xhc3M9XCJlYnRuIGVidG4tcmVkIGNhbmNlbEJ0blwiIG5nLWNsaWNrPVwiY2FuY2VsKClcIiBzdHlsZT1cIndpZHRoOjI1JVwiPnt7Y2FuY2VsVGl0bGV9fTwvc3Bhbj48L2Rpdj4nXG5cdFx0dGVtcGxhdGU6ICc8ZGl2IGNsYXNzPVwiYnRuLWdyb3VwXCI+JyArICc8YnV0dG9uIGRhdGEtbmctY2xpY2s9XCJjb25maXJtKClcIiBjbGFzcz1cImJ0biBlYnRuLWdyZWVuXCI+e3t0aXRsZX19PC9idXR0b24+JyArICc8YnV0dG9uIGRhdGEtbmctY2xpY2s9XCJjYW5jZWwoKVwiIGNsYXNzPVwiYnRuIGVidG4tcmVkIGNhbmNlbEJ0blwiPnt7Y2FuY2VsVGl0bGV9fTwvYnV0dG9uPjwvZGl2Pidcblx0fTtcbn1dKTtcbmFwcC5kaXJlY3RpdmUoJ25nRW50ZXInLCBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiBmdW5jdGlvbiAoc2NvcGUsIGVsZW1lbnQsIGF0dHJzKSB7XG5cdFx0ZWxlbWVudC5iaW5kKCdrZXlkb3duIGtleXByZXNzJywgZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0XHRpZiAoZXZlbnQud2hpY2ggPT09IDEzKSB7XG5cdFx0XHRcdHNjb3BlLiRhcHBseShmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0c2NvcGUuJGV2YWwoYXR0cnMubmdFbnRlciwgeyAnZXZlbnQnOiBldmVudCB9KTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH07XG59KTsiLCJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gTGF0TG5nKGxhdCwgbG5nKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgc2VsZi5sYXQgPSBsYXQ7XG4gIHNlbGYubG5nID0gbG5nO1xufSIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gUG9seWdvbihuYW1lLCBjb29yZHMsIGNlbnRyb2lkKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBzZWxmLm5hbWUgPSBuYW1lO1xuICBzZWxmLmNvb3JkcyA9IGNvb3JkcztcbiAgc2VsZi5jZW50cm9pZCA9IGNlbnRyb2lkO1xuXG4gIHNlbGYuaWQgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBzZWxmLm5hbWUucmVwbGFjZSgvXFwvfF8vZywgJy0nKTtcbiAgfSk7XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBUaW1lWm9uZShuYW1lLCBjb29yZHMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHNlbGYubmFtZSA9IG5hbWU7XG4gIHNlbGYuY29vcmRzID0gY29vcmRzO1xuICBzZWxmLnBvbHlnb25zID0gdW5kZWZpbmVkO1xuICBzZWxmLmNlbnRyb2lkUG9seWdvbiA9IHVuZGVmaW5lZDtcbiAgc2VsZi5ib3VuZGluZ0JveCA9IHVuZGVmaW5lZDtcblxuICBzZWxmLm1hdGNoZXNJZCA9IGZ1bmN0aW9uIChpZFRvTWF0Y2gpIHtcbiAgICByZXR1cm4gc2VsZi5pZCgpID09PSBpZFRvTWF0Y2gucmVwbGFjZSgvXFwvfF8vZywgJy0nKTtcbiAgfTtcblxuICBzZWxmLmlkID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gc2VsZi5uYW1lLnJlcGxhY2UoL1xcL3xfL2csICctJyk7XG4gIH0pO1xufSJdfQ==
